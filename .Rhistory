}
#q*xp.low + (1-q)*xp.high ;; if q is 1, all weight on xp.low; vice versa
#W is now grabbed from the ascribed fitness value at time t+1 & interpolated
W <- q*W.nr[[r]][xp.low,t+1] + (1-q)*W.nr[[r]][xp.high,t+1]
Fx <- as.numeric(pref.vec %*% (rep.gain[x] + (1-mort)*W))
value[i] <- Fx
}#end decision loop
#Record the fitness-maximizing decision
istar.nr[[r]][x,t] <- which(value == max(value))
if (length(which(value==max(value))) > 1) {
print(paste(">1 at r=",r,"x=",x,"t=",t,sep=""))
}
#Record the maximum fitness in the fitness matrix
W.nr[[r]][x,t] <- max(value)
}#end energetic state loop
}#end time loop
}#end current resource loop
#Time-invariant analysis
time.stamp <- 1
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
c.learn <- 5*(1-res.sim)^0.5
#Fitness matrices
#Build core consumer fitness matrix
W.xt <- matrix(0,cons.bs,tmax)
istar.xt <-  matrix(0,cons.bs,(tmax-1))
#Build nested fitness lists with the core being W.xt
W.nr <- list()
istar.nr <- list()
for (i in 1:num.res) {
W.nr[[i]] <- list()
istar.nr[[i]] <- list()
}
for (i in 1:num.res) {
W.nr[[i]] <- W.xt
istar.nr[[i]] <- istar.xt
}
#Build terminal fitness function
for (i in 1:num.res) {
for (x in xc:xmax) {
term.fit <- x/cons.bs
W.nr[[i]][x,tmax] <- term.fit
}
}
#Compute fitness matrices
#time
#current resource
#energetic state
#Define the encounter prob. matrix (k by res)
f.m <- f.res.patch
#Loop over 'focal resource'
for (r in 1:num.res) {
#Define decision matrix for forcal resource r
dec.m <- dec.ls[[r]]
#Loop over time
for (t in seq(tmax-1,1,-1)) {
#Loop over energetic state
for (x in seq(xc,xmax,1)) {
value.max <- -10
value <- numeric(num.dec)
#Loop over decisions
for (i in 1:num.dec) {
#Define vector of preference probabilities across resources corresp. to given decision possibility
#Each element is the preference probability for food resource i, given the current focal resource r
pref.vec <- dec.m[,i]
#Loop across resources
xp <- numeric(num.res)
for (rr in 1:num.res) {
#determine the change in x for each amt k resources (which defines the rho.vec)
delta.x <- x + rho.vec*(g.forage[rr] - (c.forage[rr] + c.learn[r,rr])) - (1-rho.vec)*(c.forage[rr] + c.learn[r,rr])
#Multiply the prob(k)*delta x and sum
xp[rr] <- f.m[,rr] %*% delta.x
#We must establish boundary conditions
# xc <= xp <= xmax
if (xp[rr] < xc) {xp[rr] <- xc}
if (xp[rr] > xmax) {xp[rr] <- xmax}
}
#Interpolation function
xp.low <- numeric(num.res); xp.high <- numeric(num.res); q <- numeric(num.res)
for (j in 1:num.res) {
if ((xp[j] != xmax) && (xp[j] != xc)) {
xp.low[j] <- as.integer(xp[j])
xp.high[j] <- xp.low[j] + 1
q[j] <- xp.high[j] - xp[j]
}
if (xp[j] == xc) {
xp.low[j] <- xc
xp.high[j] <- xc+1
q[j] <- 1
}
if (xp[j] == xmax) {
xp.low[j] <- xmax-1
xp.high[j] <- xmax
q[j] <- 0
}
}
#q*xp.low + (1-q)*xp.high ;; if q is 1, all weight on xp.low; vice versa
#W is now grabbed from the ascribed fitness value at time t+1 & interpolated
W <- q*W.nr[[r]][xp.low,t+1] + (1-q)*W.nr[[r]][xp.high,t+1]
Fx <- as.numeric(pref.vec %*% (rep.gain[x] + (1-mort)*W))
value[i] <- Fx
}#end decision loop
#Record the fitness-maximizing decision
istar.nr[[r]][x,t] <- which(value == max(value))
if (length(which(value==max(value))) > 1) {
print(paste(">1 at r=",r,"x=",x,"t=",t,sep=""))
}
#Record the maximum fitness in the fitness matrix
W.nr[[r]][x,t] <- max(value)
}#end energetic state loop
}#end time loop
}#end current resource loop
#Time-invariant analysis
time.stamp <- 1
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
c.learn <- 8*(1-res.sim)^0.5
#Fitness matrices
#Build core consumer fitness matrix
W.xt <- matrix(0,cons.bs,tmax)
istar.xt <-  matrix(0,cons.bs,(tmax-1))
#Build nested fitness lists with the core being W.xt
W.nr <- list()
istar.nr <- list()
for (i in 1:num.res) {
W.nr[[i]] <- list()
istar.nr[[i]] <- list()
}
for (i in 1:num.res) {
W.nr[[i]] <- W.xt
istar.nr[[i]] <- istar.xt
}
#Build terminal fitness function
for (i in 1:num.res) {
for (x in xc:xmax) {
term.fit <- x/cons.bs
W.nr[[i]][x,tmax] <- term.fit
}
}
#Compute fitness matrices
#time
#current resource
#energetic state
#Define the encounter prob. matrix (k by res)
f.m <- f.res.patch
#Loop over 'focal resource'
for (r in 1:num.res) {
#Define decision matrix for forcal resource r
dec.m <- dec.ls[[r]]
#Loop over time
for (t in seq(tmax-1,1,-1)) {
#Loop over energetic state
for (x in seq(xc,xmax,1)) {
value.max <- -10
value <- numeric(num.dec)
#Loop over decisions
for (i in 1:num.dec) {
#Define vector of preference probabilities across resources corresp. to given decision possibility
#Each element is the preference probability for food resource i, given the current focal resource r
pref.vec <- dec.m[,i]
#Loop across resources
xp <- numeric(num.res)
for (rr in 1:num.res) {
#determine the change in x for each amt k resources (which defines the rho.vec)
delta.x <- x + rho.vec*(g.forage[rr] - (c.forage[rr] + c.learn[r,rr])) - (1-rho.vec)*(c.forage[rr] + c.learn[r,rr])
#Multiply the prob(k)*delta x and sum
xp[rr] <- f.m[,rr] %*% delta.x
#We must establish boundary conditions
# xc <= xp <= xmax
if (xp[rr] < xc) {xp[rr] <- xc}
if (xp[rr] > xmax) {xp[rr] <- xmax}
}
#Interpolation function
xp.low <- numeric(num.res); xp.high <- numeric(num.res); q <- numeric(num.res)
for (j in 1:num.res) {
if ((xp[j] != xmax) && (xp[j] != xc)) {
xp.low[j] <- as.integer(xp[j])
xp.high[j] <- xp.low[j] + 1
q[j] <- xp.high[j] - xp[j]
}
if (xp[j] == xc) {
xp.low[j] <- xc
xp.high[j] <- xc+1
q[j] <- 1
}
if (xp[j] == xmax) {
xp.low[j] <- xmax-1
xp.high[j] <- xmax
q[j] <- 0
}
}
#q*xp.low + (1-q)*xp.high ;; if q is 1, all weight on xp.low; vice versa
#W is now grabbed from the ascribed fitness value at time t+1 & interpolated
W <- q*W.nr[[r]][xp.low,t+1] + (1-q)*W.nr[[r]][xp.high,t+1]
Fx <- as.numeric(pref.vec %*% (rep.gain[x] + (1-mort)*W))
value[i] <- Fx
}#end decision loop
#Record the fitness-maximizing decision
istar.nr[[r]][x,t] <- which(value == max(value))
if (length(which(value==max(value))) > 1) {
print(paste(">1 at r=",r,"x=",x,"t=",t,sep=""))
}
#Record the maximum fitness in the fitness matrix
W.nr[[r]][x,t] <- max(value)
}#end energetic state loop
}#end time loop
}#end current resource loop
#Time-invariant analysis
time.stamp <- 1
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
istar.node
c.learn <- 5*(1-res.sim)^0.5
c.learn
c.learn <- 5*(1-res.sim)^0.5 + 1
#Fitness matrices
#Build core consumer fitness matrix
W.xt <- matrix(0,cons.bs,tmax)
istar.xt <-  matrix(0,cons.bs,(tmax-1))
#Build nested fitness lists with the core being W.xt
W.nr <- list()
istar.nr <- list()
for (i in 1:num.res) {
W.nr[[i]] <- list()
istar.nr[[i]] <- list()
}
for (i in 1:num.res) {
W.nr[[i]] <- W.xt
istar.nr[[i]] <- istar.xt
}
#Build terminal fitness function
for (i in 1:num.res) {
for (x in xc:xmax) {
term.fit <- x/cons.bs
W.nr[[i]][x,tmax] <- term.fit
}
}
#Compute fitness matrices
#time
#current resource
#energetic state
#Define the encounter prob. matrix (k by res)
f.m <- f.res.patch
#Loop over 'focal resource'
for (r in 1:num.res) {
#Define decision matrix for forcal resource r
dec.m <- dec.ls[[r]]
#Loop over time
for (t in seq(tmax-1,1,-1)) {
#Loop over energetic state
for (x in seq(xc,xmax,1)) {
value.max <- -10
value <- numeric(num.dec)
#Loop over decisions
for (i in 1:num.dec) {
#Define vector of preference probabilities across resources corresp. to given decision possibility
#Each element is the preference probability for food resource i, given the current focal resource r
pref.vec <- dec.m[,i]
#Loop across resources
xp <- numeric(num.res)
for (rr in 1:num.res) {
#determine the change in x for each amt k resources (which defines the rho.vec)
delta.x <- x + rho.vec*(g.forage[rr] - (c.forage[rr] + c.learn[r,rr])) - (1-rho.vec)*(c.forage[rr] + c.learn[r,rr])
#Multiply the prob(k)*delta x and sum
xp[rr] <- f.m[,rr] %*% delta.x
#We must establish boundary conditions
# xc <= xp <= xmax
if (xp[rr] < xc) {xp[rr] <- xc}
if (xp[rr] > xmax) {xp[rr] <- xmax}
}
#Interpolation function
xp.low <- numeric(num.res); xp.high <- numeric(num.res); q <- numeric(num.res)
for (j in 1:num.res) {
if ((xp[j] != xmax) && (xp[j] != xc)) {
xp.low[j] <- as.integer(xp[j])
xp.high[j] <- xp.low[j] + 1
q[j] <- xp.high[j] - xp[j]
}
if (xp[j] == xc) {
xp.low[j] <- xc
xp.high[j] <- xc+1
q[j] <- 1
}
if (xp[j] == xmax) {
xp.low[j] <- xmax-1
xp.high[j] <- xmax
q[j] <- 0
}
}
#q*xp.low + (1-q)*xp.high ;; if q is 1, all weight on xp.low; vice versa
#W is now grabbed from the ascribed fitness value at time t+1 & interpolated
W <- q*W.nr[[r]][xp.low,t+1] + (1-q)*W.nr[[r]][xp.high,t+1]
Fx <- as.numeric(pref.vec %*% (rep.gain[x] + (1-mort)*W))
value[i] <- Fx
}#end decision loop
#Record the fitness-maximizing decision
istar.nr[[r]][x,t] <- which(value == max(value))
if (length(which(value==max(value))) > 1) {
print(paste(">1 at r=",r,"x=",x,"t=",t,sep=""))
}
#Record the maximum fitness in the fitness matrix
W.nr[[r]][x,t] <- max(value)
}#end energetic state loop
}#end time loop
}#end current resource loop
#Time-invariant analysis
time.stamp <- 1
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
time.stamp <- 9
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
c.learn <- 0*(1-res.sim)^0.5 + 1
c.learn
learn.mag <- 0
learn.skew <- 0.5
c.learn <- learn.mag*(1-res.sim)^learn.skew
c.learn
learn.mag <- 0
learn.skew <- 0.5
c.learn <- learn.mag*(1-res.sim)^learn.skew
#Fitness matrices
#Build core consumer fitness matrix
W.xt <- matrix(0,cons.bs,tmax)
istar.xt <-  matrix(0,cons.bs,(tmax-1))
#Build nested fitness lists with the core being W.xt
W.nr <- list()
istar.nr <- list()
for (i in 1:num.res) {
W.nr[[i]] <- list()
istar.nr[[i]] <- list()
}
for (i in 1:num.res) {
W.nr[[i]] <- W.xt
istar.nr[[i]] <- istar.xt
}
#Build terminal fitness function
for (i in 1:num.res) {
for (x in xc:xmax) {
term.fit <- x/cons.bs
W.nr[[i]][x,tmax] <- term.fit
}
}
#Compute fitness matrices
#time
#current resource
#energetic state
#Define the encounter prob. matrix (k by res)
f.m <- f.res.patch
#Loop over 'focal resource'
for (r in 1:num.res) {
#Define decision matrix for forcal resource r
dec.m <- dec.ls[[r]]
#Loop over time
for (t in seq(tmax-1,1,-1)) {
#Loop over energetic state
for (x in seq(xc,xmax,1)) {
value.max <- -10
value <- numeric(num.dec)
#Loop over decisions
for (i in 1:num.dec) {
#Define vector of preference probabilities across resources corresp. to given decision possibility
#Each element is the preference probability for food resource i, given the current focal resource r
pref.vec <- dec.m[,i]
#Loop across resources
xp <- numeric(num.res)
for (rr in 1:num.res) {
#determine the change in x for each amt k resources (which defines the rho.vec)
delta.x <- x + rho.vec*(g.forage[rr] - (c.forage[rr] + c.learn[r,rr])) - (1-rho.vec)*(c.forage[rr] + c.learn[r,rr])
#Multiply the prob(k)*delta x and sum
xp[rr] <- f.m[,rr] %*% delta.x
#We must establish boundary conditions
# xc <= xp <= xmax
if (xp[rr] < xc) {xp[rr] <- xc}
if (xp[rr] > xmax) {xp[rr] <- xmax}
}
#Interpolation function
xp.low <- numeric(num.res); xp.high <- numeric(num.res); q <- numeric(num.res)
for (j in 1:num.res) {
if ((xp[j] != xmax) && (xp[j] != xc)) {
xp.low[j] <- as.integer(xp[j])
xp.high[j] <- xp.low[j] + 1
q[j] <- xp.high[j] - xp[j]
}
if (xp[j] == xc) {
xp.low[j] <- xc
xp.high[j] <- xc+1
q[j] <- 1
}
if (xp[j] == xmax) {
xp.low[j] <- xmax-1
xp.high[j] <- xmax
q[j] <- 0
}
}
#q*xp.low + (1-q)*xp.high ;; if q is 1, all weight on xp.low; vice versa
#W is now grabbed from the ascribed fitness value at time t+1 & interpolated
W <- q*W.nr[[r]][xp.low,t+1] + (1-q)*W.nr[[r]][xp.high,t+1]
Fx <- as.numeric(pref.vec %*% (rep.gain[x] + (1-mort)*W))
value[i] <- Fx
}#end decision loop
#Record the fitness-maximizing decision
istar.nr[[r]][x,t] <- which(value == max(value))
if (length(which(value==max(value))) > 1) {
print(paste(">1 at r=",r,"x=",x,"t=",t,sep=""))
}
#Record the maximum fitness in the fitness matrix
W.nr[[r]][x,t] <- max(value)
}#end energetic state loop
}#end time loop
}#end current resource loop
#Time-invariant analysis
time.stamp <- 9
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
mean.beta
param.beta
plot(param.beta)
time.stamp <- 9
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
