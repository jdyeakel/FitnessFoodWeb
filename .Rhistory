term.fit <- x/res.bs[j]
W.nr[[i]][[j]][x,tmax] <- term.fit
}
}
}
istar.nr[[1]][[1]]
tmax
W.nr[[1]][[1]]
res.bs
22/10
#Build terminal fitness function
for (i in 1:n) {
for (j in 1:num.res) {
for (x in xc:xmax) {
term.fit <- (res.bs[j] - (res.bs[j]- x ))/res.bs[j] * 100
W.nr[[i]][[j]][x,tmax] <- term.fit
}
}
}
#Build terminal fitness function
for (i in 1:n) {
for (j in 1:num.res) {
for (x in xc:xmax) {
term.fit <- (res.bs[j] - (res.bs[j]- x ))/res.bs[j]
W.nr[[i]][[j]][x,tmax] <- term.fit
}
}
}
W.nr[[1]][[1]]
#Build terminal fitness function
for (i in 1:n) {
for (j in 1:num.res) {
for (x in xc:xmax) {
term.fit <- 1 + (x/res.bs[j])
W.nr[[i]][[j]][x,tmax] <- term.fit
}
}
}
W.nr[[1]][[1]]
#Build terminal fitness function
for (i in 1:n) {
for (j in 1:num.res) {
for (x in xc:xmax) {
term.fit <- 1 - (x/cons.bs)
W.nr[[i]][[j]][x,tmax] <- term.fit
}
}
}
W.nr[[1]][[1]]
#Build terminal fitness function
for (i in 1:n) {
for (j in 1:num.res) {
for (x in xc:xmax) {
term.fit <- 1 + (x/cons.bs)
W.nr[[i]][[j]][x,tmax] <- term.fit
}
}
}
W.nr[[1]][[1]]
#Build terminal fitness function
for (i in 1:n) {
for (j in 1:num.res) {
for (x in xc:xmax) {
term.fit <- x/cons.bs
W.nr[[i]][[j]][x,tmax] <- term.fit
}
}
}
W.nr[[1]][[1]]
plot(W.nr[[1]][[1]][,tmax])
xi
dec.ls[[1]]
k
max.enc+1
encounters <- seq(0,max.enc,1)
encounters
length(encounters)
rho
rho.vec
rho
rho.vec <- 1 - exp(-encounters^2/max(encounters))
rho.vec
plot(rho.vec)
xi[1,]
f.res.patch[[1]]
rho.vec
epsilon
forage.gain
gain.forage
f.gain
g.forage
c.forage
(1-rho.vec)*c.forage
rho.vec*(g.forage[rr] - c.forage)
rr = 1
rho.vec*(g.forage[rr] - c.forage)
rho.vec*(g.forage[rr] - c.forage) - (1-rho.vec)*c.forage
r1 <- rho.vec*(g.forage[rr] - c.forage)
r2 <- (1-rho.vec)*c.forage
r1 - r2
xp <- x + rho.vec*(g.forage[rr] - c.forage) - (1-rho.vec)*c.forage
xp
f.res.patch[[1]]
length(xp)
W
#Loop across resources
W <- numeric(num.res)
for (rr in 1:num.res) {
xp <- x + rho.vec*(g.forage[rr] - c.forage) - (1-rho.vec)*c.forage
W[rr] <- f.m %*% xp
}
node=1
f.m <- f.res.patch[[node]]
#Loop across resources
W <- numeric(num.res)
for (rr in 1:num.res) {
xp <- x + rho.vec*(g.forage[rr] - c.forage) - (1-rho.vec)*c.forage
W[rr] <- f.m %*% xp
}
#Loop across resources
W <- numeric(num.res)
for (rr in 1:num.res) {
xp <- x + rho.vec*(g.forage[rr] - c.forage) - (1-rho.vec)*c.forage
W[rr] <- f.m[,rr] %*% xp
}
W
res.bs
mort
W
mort*W
mort[1]*W[1]
mort[2]*W[2]
mort[3]*W[3]
(1-mort)*W
rep.gain <- numeric(xmax)
for (i in xc:xmax) {
rep.gain[i] <- i/10
}
rep.gain
rep.gain <- numeric(xmax)
for (i in xc:xmax) {
rep.gain[i] <- i/(10*conx.bs)
}
rep.gain <- numeric(xmax)
for (i in xc:xmax) {
rep.gain[i] <- i/(10*cons.bs)
}
rep.gain
xmax
xc
x = 18
pref.vec
r = 1
dec.m <- dec.ls[[r]]
dec.m
pref.vec <- dec.m[,i]
i = 1
pref.vec <- dec.m[,i]
pref.vec
x
(rep.gain[x] + (1-mort)*W)
rep.gain[x]
(1-mort)*W
W
xp
x
#Loop across resources
W <- numeric(num.res)
for (rr in 1:num.res) {
xp <- x + rho.vec*(g.forage[rr] - c.forage) - (1-rho.vec)*c.forage
W[rr] <- f.m[,rr] %*% xp
}
W
Fx <- pref.vec %*% (rep.gain[x] + (1-mort)*W)
Fx
(rep.gain[x] + (1-mort)*W)
pref.vec
pref.vec %*% (rep.gain[x] + (1-mort)*W)
as.numeric(pref.vec %*% (rep.gain[x] + (1-mort)*W))
res.sim
res.bs
cons.bs
W
round(W,0)
W.low <- round(W,0)
W.high <- W_low + 1
W.low <- round(W,0)
W.high <- W.low + 1
W.low
W.high
W - W.low
q <- W.high - W
W
q
W
q
w
#Loop across resources
xp <- numeric(num.res)
for (rr in 1:num.res) {
delta.x <- x + rho.vec*(g.forage[rr] - c.forage) - (1-rho.vec)*c.forage
xp[rr] <- f.m[,rr] %*% delta.x
}
xp
W
if (xp < xc) {xp <- xc}
if (xp > xmax) {xp <- xmax}
#Loop across resources
xp <- numeric(num.res)
for (rr in 1:num.res) {
delta.x <- x + rho.vec*(g.forage[rr] - c.forage) - (1-rho.vec)*c.forage
xp[rr] <- f.m[,rr] %*% delta.x
#We must establish boundary conditions
# xc <= xp <= xmax
if (xp[rr] < xc) {xp[rr] <- xc}
if (xp[rr] > xmax) {xp[rr] <- xmax}
}
xp
xc
#Interpolation function
xp.low <- round(xp,0)
xp.high <- xp.low + 1
q <- xp.high - xp
xp.low
xp.high
q
node
r
W.nr[[node]][[r]][xp.low,t+1]
q*W.nr[[node]][[r]]
t
t <- tmax-1
q*W.nr[[node]][[r]]
W.nr[[node]][[r]][xp.low,t+1]
q*W.nr[[node]][[r]][xp.low,t+1]
q
0.9561102*0.7272727
q*W.nr[[node]][[r]][xp.low,t+1][[5]]
(q*W.nr[[node]][[r]][xp.low,t+1])[[5]]
(W.nr[[node]][[r]][xp.low,t+1])[[5]]*q[[5]]
W.nr[[node]][[r]][xp.low,t+1]
W.nr[[node]][[r]][xp.high,t+1]
(1-q)
W <- q*W.nr[[node]][[r]][xp.low,t+1] + (1-q)*W.nr[[node]][[r]][xp.high,t+1]
W
pref.vec
rep.gain[x]
rep.gain
rep.gain[x]
Fx <- as.numeric(pref.vec %*% (rep.gain[x] + (1-mort)*W))
Fx
value.max <- -10
value <- numeric(num.dec)
#Loop over decisions
for (i in 1:num.dec) {
#Define vector of preference probabilities across resources corresp. to given decision possibility
pref.vec <- dec.m[,i]
#Loop across resources
xp <- numeric(num.res)
for (rr in 1:num.res) {
delta.x <- x + rho.vec*(g.forage[rr] - c.forage) - (1-rho.vec)*c.forage
xp[rr] <- f.m[,rr] %*% delta.x
#We must establish boundary conditions
# xc <= xp <= xmax
if (xp[rr] < xc) {xp[rr] <- xc}
if (xp[rr] > xmax) {xp[rr] <- xmax}
}
#Interpolation function
xp.low <- round(xp,0)
xp.high <- xp.low + 1
q <- xp.high - xp
#q*xp.low + (1-q)*xp.high ;; if q is 1, all weight on xp.low; vice versa
#W is now grabbed from the ascribed fitness value at time t+1 & interpolated
W <- q*W.nr[[node]][[r]][xp.low,t+1] + (1-q)*W.nr[[node]][[r]][xp.high,t+1]
Fx <- as.numeric(pref.vec %*% (rep.gain[x] + (1-mort)*W))
value[i] <- Fx
}#end decision loop
value
plot(value)
plot(value,type="l")
res.sim
params.beta
param.beta
which(value == max(value))
length(istar)
length(istar.nr)
length(istar.nr[[1]])
length(istar.nr[[1]][[1]])
istar.nr[[1]][[1]]
x
xc
mean.beta
r
res.sim
res.bs
Fx
W
value[which(value == max(value))]
W.nr[[1]][[1]]
xc
#Loop over energetic state
for (x in seq(xc,xmax,1)) {
value.max <- -10
value <- numeric(num.dec)
#Loop over decisions
for (i in 1:num.dec) {
#Define vector of preference probabilities across resources corresp. to given decision possibility
pref.vec <- dec.m[,i]
#Loop across resources
xp <- numeric(num.res)
for (rr in 1:num.res) {
delta.x <- x + rho.vec*(g.forage[rr] - c.forage) - (1-rho.vec)*c.forage
xp[rr] <- f.m[,rr] %*% delta.x
#We must establish boundary conditions
# xc <= xp <= xmax
if (xp[rr] < xc) {xp[rr] <- xc}
if (xp[rr] > xmax) {xp[rr] <- xmax}
}
#Interpolation function
xp.low <- round(xp,0)
xp.high <- xp.low + 1
q <- xp.high - xp
#q*xp.low + (1-q)*xp.high ;; if q is 1, all weight on xp.low; vice versa
#W is now grabbed from the ascribed fitness value at time t+1 & interpolated
W <- q*W.nr[[node]][[r]][xp.low,t+1] + (1-q)*W.nr[[node]][[r]][xp.high,t+1]
Fx <- as.numeric(pref.vec %*% (rep.gain[x] + (1-mort)*W))
value[i] <- Fx
}#end decision loop
#Record the fitness-maximizing decision
istar.nr[[node]][[r]][x,t] <- which(value == max(value))
#Record the maximum fitness in the fitness matrix
W.nr[[node]][[r]][x,t] <- max(value)
}#end energetic state loop
W.nr[[1]][[1]]
#Loop over time
for (t in seq(tmax-1,1,-1)) {
#Loop over energetic state
for (x in seq(xc,xmax,1)) {
value.max <- -10
value <- numeric(num.dec)
#Loop over decisions
for (i in 1:num.dec) {
#Define vector of preference probabilities across resources corresp. to given decision possibility
pref.vec <- dec.m[,i]
#Loop across resources
xp <- numeric(num.res)
for (rr in 1:num.res) {
delta.x <- x + rho.vec*(g.forage[rr] - c.forage) - (1-rho.vec)*c.forage
xp[rr] <- f.m[,rr] %*% delta.x
#We must establish boundary conditions
# xc <= xp <= xmax
if (xp[rr] < xc) {xp[rr] <- xc}
if (xp[rr] > xmax) {xp[rr] <- xmax}
}
#Interpolation function
xp.low <- round(xp,0)
xp.high <- xp.low + 1
q <- xp.high - xp
#q*xp.low + (1-q)*xp.high ;; if q is 1, all weight on xp.low; vice versa
#W is now grabbed from the ascribed fitness value at time t+1 & interpolated
W <- q*W.nr[[node]][[r]][xp.low,t+1] + (1-q)*W.nr[[node]][[r]][xp.high,t+1]
Fx <- as.numeric(pref.vec %*% (rep.gain[x] + (1-mort)*W))
value[i] <- Fx
}#end decision loop
#Record the fitness-maximizing decision
istar.nr[[node]][[r]][x,t] <- which(value == max(value))
#Record the maximum fitness in the fitness matrix
W.nr[[node]][[r]][x,t] <- max(value)
}#end energetic state loop
}#end time loop
W.nr[[1]][[1]]
istar.nr[[1]][[1]]
#Loop over 'focal resource'
for (r in 1:num.res) {
#Define decision matrix for forcal resource r
dec.m <- dec.ls[[r]]
#Loop over time
for (t in seq(tmax-1,1,-1)) {
#Loop over energetic state
for (x in seq(xc,xmax,1)) {
value.max <- -10
value <- numeric(num.dec)
#Loop over decisions
for (i in 1:num.dec) {
#Define vector of preference probabilities across resources corresp. to given decision possibility
pref.vec <- dec.m[,i]
#Loop across resources
xp <- numeric(num.res)
for (rr in 1:num.res) {
delta.x <- x + rho.vec*(g.forage[rr] - c.forage) - (1-rho.vec)*c.forage
xp[rr] <- f.m[,rr] %*% delta.x
#We must establish boundary conditions
# xc <= xp <= xmax
if (xp[rr] < xc) {xp[rr] <- xc}
if (xp[rr] > xmax) {xp[rr] <- xmax}
}
#Interpolation function
xp.low <- round(xp,0)
xp.high <- xp.low + 1
q <- xp.high - xp
#q*xp.low + (1-q)*xp.high ;; if q is 1, all weight on xp.low; vice versa
#W is now grabbed from the ascribed fitness value at time t+1 & interpolated
W <- q*W.nr[[node]][[r]][xp.low,t+1] + (1-q)*W.nr[[node]][[r]][xp.high,t+1]
Fx <- as.numeric(pref.vec %*% (rep.gain[x] + (1-mort)*W))
value[i] <- Fx
}#end decision loop
#Record the fitness-maximizing decision
istar.nr[[node]][[r]][x,t] <- which(value == max(value))
#Record the maximum fitness in the fitness matrix
W.nr[[node]][[r]][x,t] <- max(value)
}#end energetic state loop
}#end time loop
}#end current resource loop
istar.nr[[1]][[1]]
istar.nr[[1]][[2]]
istar.nr[[1]][[3]]
istar.nr[[1]][[4]]
istar.nr[[1]][[5]]
istar.nr[[1]][[4]]
istar.nr[[1]][[3]]
istar.nr[[1]][[2]]
istar.nr[[1]][[1]]
res.bs
for (node in 1:n) {
print(paste("Node:",node,sep=""))
#Define the encounter prob. matrix (k by res)
f.m <- f.res.patch[[node]]
#Loop over 'focal resource'
for (r in 1:num.res) {
#Define decision matrix for forcal resource r
dec.m <- dec.ls[[r]]
#Loop over time
for (t in seq(tmax-1,1,-1)) {
#Loop over energetic state
for (x in seq(xc,xmax,1)) {
value.max <- -10
value <- numeric(num.dec)
#Loop over decisions
for (i in 1:num.dec) {
#Define vector of preference probabilities across resources corresp. to given decision possibility
pref.vec <- dec.m[,i]
#Loop across resources
xp <- numeric(num.res)
for (rr in 1:num.res) {
delta.x <- x + rho.vec*(g.forage[rr] - c.forage) - (1-rho.vec)*c.forage
xp[rr] <- f.m[,rr] %*% delta.x
#We must establish boundary conditions
# xc <= xp <= xmax
if (xp[rr] < xc) {xp[rr] <- xc}
if (xp[rr] > xmax) {xp[rr] <- xmax}
}
#Interpolation function
xp.low <- round(xp,0)
xp.high <- xp.low + 1
q <- xp.high - xp
#q*xp.low + (1-q)*xp.high ;; if q is 1, all weight on xp.low; vice versa
#W is now grabbed from the ascribed fitness value at time t+1 & interpolated
W <- q*W.nr[[node]][[r]][xp.low,t+1] + (1-q)*W.nr[[node]][[r]][xp.high,t+1]
Fx <- as.numeric(pref.vec %*% (rep.gain[x] + (1-mort)*W))
value[i] <- Fx
}#end decision loop
#Record the fitness-maximizing decision
istar.nr[[node]][[r]][x,t] <- which(value == max(value))
#Record the maximum fitness in the fitness matrix
W.nr[[node]][[r]][x,t] <- max(value)
}#end energetic state loop
}#end time loop
}#end current resource loop
}#end node loop
istar.nr[[1]][[1]]
istar.nr[[2]][[1]]
istar.nr[[3]][[1]]
istar.nr[[10]][[1]]
istar.nr[[1]][[3]]
istar.nr[[2]][[3]]
istar.nr[[3]][[3]]
istar.nr[[4]][[3]]
istar.nr[[5]][[3]]
istar.nr[[25]][[3]]
W.nr[[1]][[1]]
plot(W.nr[[1]][[1]])
plot(W.nr[[1]][[1]][14,],type="l")
plot(W.nr[[1]][[1]][14,],type="l")
lines(W.nr[[1]][[1]][15,],type="l")
lines(W.nr[[1]][[1]][16,],type="l")
lines(W.nr[[1]][[1]][17,],type="l")
lines(W.nr[[1]][[1]][18,],type="l")
lines(W.nr[[1]][[1]][20,],type="l")
lines(W.nr[[1]][[1]][21,],type="l")
lines(W.nr[[1]][[1]][22,],type="l")
plot(W.nr[[1]][[1]][22,],type="l")
f.m
rho.vec
g.forage
c.forage
rho.vec
rho.vec
plot(encounters,rho.vec)
f.m
apply(f.m,2,sum)
pref.vec
i
res.sim
forage.gain
f.gain
g.forage
c.forage
c.rep
rep.gain
mort
W
plot(W)
