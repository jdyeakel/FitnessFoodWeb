#Mean encounter rates of prey in region i should be scaled to the number of nearest neighbors to i
#Dispersion of prey in region i should be scaled to the variability in nearest neighbors to nearest neighbors in i
xi <- matrix(0,n,num.res)
nu <- matrix(0,n,num.res)
for (i in 1:n) {
for (j in 1:num.res) {
xi[i,j] <- (1/res.bs[j])*10*num.nn[i]
nu[i,j] <- (1/res.bs[j])*10*(nn2.sd[i]+1)
}
}
max.enc <- 20
f.patch <- vector("list",n)
f.res.patch <- lapply(f.patch,function(x){matrix(0,(max.enc+1),num.res)})
for (i in 1:n) {
for (j in 1:num.res) {
for (k in 1:(max.enc+1)) {
f.res.patch[[i]][k,j] <-  dnbinom(k,mu = xi[i,j], size = nu[i,j])
}
f.res.patch[[i]][,j] <- f.res.patch[[i]][,j] / sum(f.res.patch[[i]][,j])
}
}
plot(f.res.patch[[1]][,1])
plot(f.res.patch[[1]][,2])
plot(f.res.patch[[1]][,3])
plot(f.res.patch[[1]][,4])
plot(f.res.patch[[1]][,5])
plot(f.res.patch[[1]][,6])
plot(f.res.patch[[1]][,1])
plot(f.res.patch[[2]][,1])
plot(f.res.patch[[3]][,1])
plot(f.res.patch[[4]][,1])
xi
nu
xi <- matrix(0,n,num.res)
nu <- matrix(0,n,num.res)
for (i in 1:n) {
for (j in 1:num.res) {
xi[i,j] <- (1/res.bs[j])*10*num.nn[i]
nu[i,j] <- (1/res.bs[j])*10*(nn2.sd[i]+2)
}
}
nu
max.enc <- 20
f.patch <- vector("list",n)
f.res.patch <- lapply(f.patch,function(x){matrix(0,(max.enc+1),num.res)})
for (i in 1:n) {
for (j in 1:num.res) {
for (k in 1:(max.enc+1)) {
f.res.patch[[i]][k,j] <-  dnbinom(k,mu = xi[i,j], size = nu[i,j])
}
f.res.patch[[i]][,j] <- f.res.patch[[i]][,j] / sum(f.res.patch[[i]][,j])
}
}
plot(f.res.patch[[4]][,1])
boxplot(nu)
boxplot(xi)
nn2.sd
nn2.sd+1
xi <- matrix(0,n,num.res)
nu <- matrix(0,n,num.res)
for (i in 1:n) {
for (j in 1:num.res) {
xi[i,j] <- (1/res.bs[j])*10*num.nn[i]
#nu[i,j] <- (1/res.bs[j])*10*(nn2.sd[i]+2)
nu[i,j] <- nn2.sd[i]*2
}
}
nu
nn2.sd
plot(lattice.net,vertex.size=degree(lattice.net),vertex.color=nn2.sd,edge.color="lightblue",edge.arrow.size=0.6)
plot(lattice.net,vertex.size=degree(lattice.net),vertex.color=nn2.sd*10,edge.color="lightblue",edge.arrow.size=0.6)
nn2.sd*10
plot(lattice.net,vertex.size=nn2.sd*2,vertex.color=colors[1],edge.color="lightblue",edge.arrow.size=0.6)
plot(lattice.net,vertex.size=nn2.sd*10,vertex.color=colors[1],edge.color="lightblue",edge.arrow.size=0.6)
plot(lattice.net,vertex.size=nn2.sd*10,vertex.labels=NA,vertex.color=colors[1],edge.color="lightblue",edge.arrow.size=0.6)
plot(lattice.net,vertex.size=nn2.sd*10,vertex.label=NA,vertex.color=colors[1],edge.color="lightblue",edge.arrow.size=0.6)
plot(lattice.net,vertex.size=(nn2.sd+1)*10,vertex.label=NA,vertex.color=colors[1],edge.color="lightblue",edge.arrow.size=0.6)
plot(lattice.net,vertex.size=(nn2.sd+1)*2,vertex.label=NA,vertex.color=colors[1],edge.color="lightblue",edge.arrow.size=0.6)
plot(lattice.net,vertex.size=(nn2.sd+1)*3,vertex.label=NA,vertex.color=colors[1],edge.color="lightblue",edge.arrow.size=0.6)
mort <- 0.5 - (0.5 - 0.1)^(cons.bs/res.bs)^2
mort
res.bs
mort <- 0.5 - (0.5 - 0.1)^(res.bs/cons.bs)^2
mort
mort <- 0.5 - (0.5 - 0.1)^((res.bs/cons.bs)^2)
mort
((res.bs/cons.bs)^2)
(0.5 - 0.1)
0.4^).13
0.4^0.13
Ratio.RC <- res.bs/cons.bs
mp1 <- 0.1
mort <- 0.5 - 0.5*(1 - 2*mp1)^(Ratio.RC^2)
mort
mp1 <- 0.2
mort <- 0.5 - 0.5*(1 - 2*mp1)^(Ratio.RC^2)
mort
res.bs
plot(res.bs,mort)
2 * cons.bs^0.3
c_forage <- 2 * cons.bs^0.3
c_forage
g_forage <- numeric(num.res)
for (i in 1:num.res) {
#Foraging costs/gains conditional on consumer AND resource
eta[i] <- 0.5
#Gains/costs scale allometrically
g_forage[i] <- eta[i]*res.bs[i]
}
eta <- numeric(num.res)
g_forage <- numeric(num.res)
for (i in 1:num.res) {
#Foraging costs/gains conditional on consumer AND resource
eta[i] <- 0.5
#Gains/costs scale allometrically
g_forage[i] <- eta[i]*res.bs[i]
}
g_forage
c.forage
c.forage <- 2 * cons.bs^0.3
c.rep <- 0.05*cons.bs
eta <- numeric(num.res)
g.forage <- numeric(num.res)
for (i in 1:num.res) {
#Foraging costs/gains conditional on consumer AND resource
eta[i] <- 0.5
#Gains/costs scale allometrically
g.forage[i] <- eta[i]*res.bs[i]
}
g.forage
c.forage
c.forage <- 1 * cons.bs^0.5
c.forage
c.forage <- 2 * cons.bs^0.5
c.forage
c.forage <- 2 * cons.bs^(3/4)
c.forage
c.forage <- cons.bs^(3/4)
c.forage
cons.bio
cons.bs
for (i in 1:num.res) {
#Foraging costs/gains conditional on consumer AND resource
eta[i] <- 0.1
#Gains/costs scale allometrically
g.forage[i] <- eta[i]*res.bs[i]
}
g.forage
c.forage <- cons.bs^(1/4)
c.forage
g.forage
num.dec <- 10
beta.a <- seq(1,5,(5-1)/num.decisions)
?seq
num.dec <- 10
beta.a <- seq(1,5,length.out = num.dec)
beta.a
a.beta <- seq(1,5,length.out = num.dec)
b.beta <- seq(5,1,length.out = num.dec)
mean.beta <- a.beta/(a.beta + b.beta)
mean.beta
plot(mean.beta)
param.beta <- cbind(a.beta,b.beta)
param.beta
plot(param.beta)
node
r
xc
seq(xc,xmax,1)
seq(xc,xmax,by=1)
sc
xc
xmax
xmax <- cons.bs
seq(xc,xmax,1)
seq(xc,xmax,1)*num.res*num.dec*tmax*n
length(seq(xc,xmax,1))*num.res*num.dec*tmax*n
n
tmax
num.dec
num.res
tmax
res.sim <- matrix(0,num.res,num.res)
for (i in 1:num.res) {
for (j in 1:num.res) {
resi.att <- c(res.bs[i]) #in multidimensional trait space, this would be a vector of attributes
resj.att <- c(res.bs[j])
res.sim[i,j] <- (resi.att %*% resj.att)/ sqrt(resi.att %*% resi.att * resj.att %*% resj.att)
}
}
res.sim
i = 1
j =
1
resi.att <- c(res.bs[i]) #in multidimensional trait space, this would be a vector of attributes
resj.att <- c(res.bs[j])
resi.att
resj.att
(resi.att %*% resj.att)
sqrt(resi.att %*% resi.att * resj.att %*% resj.att)
j = 2
resi.att <- c(res.bs[i]) #in multidimensional trait space, this would be a vector of attributes
resj.att <- c(res.bs[j])
resi.att
resj.att
(resi.att %*% resj.att)
sqrt(resi.att %*% resi.att * resj.att %*% resj.att)
(resi.att %*% resi.att
)
resj.att %*% resj.att
res.sim <- matrix(0,num.res,num.res)
for (i in 1:num.res) {
for (j in 1:num.res) {
resi.att <- c(res.bs[i]) #in multidimensional trait space, this would be a vector of attributes
resj.att <- c(res.bs[j])
res.sim[i,j] <- (resi.att %*% resj.att)/ sqrt((resi.att %*% resi.att) * (resj.att %*% resj.att))
}
}
res.sim
(resi.att %*% resi.att) * (resj.att %*% resj.att)
sqrt((resi.att %*% resi.att) * (resj.att %*% resj.att))
(resi.att %*% resj.att)
install.packages(arules)
install.packages("arules")
library(arules)
3 %in% c(1,2,3)
3 %in% c(1,2)
dissimilarity(1,2,method="cosine")
dissimilarity(c(1,1),c(1,2),method="cosine")
#Resource similarity ~ cosine similarity index
res.sim <- matrix(0,num.res,num.res)
for (i in 1:num.res) {
for (j in 1:num.res) {
resi.att <- c(1,res.bs[i]) #in multidimensional trait space, this would be a vector of attributes
resj.att <- c(1,res.bs[j])
res.sim[i,j] <- (resi.att %*% resj.att)/ sqrt((resi.att %*% resi.att) * (resj.att %*% resj.att))
}
}
res.sim
res.sim - min(res.sim)
res.sim.low <- res.sim - min(res.sim)
res.sim <- res.sim.low / max(res.sim.low)
res.sim
plot(res.sim)
plot(as.numeric(res.sim))
#Resource similarity ~ cosine similarity index
res.sim <- matrix(0,num.res,num.res)
for (i in 1:num.res) {
for (j in 1:num.res) {
resi.att <- c(1,res.bs[i]) #in multidimensional trait space, this would be a vector of attributes
resj.att <- c(1,res.bs[j])
res.sim[i,j] <- (resi.att %*% resj.att)/ sqrt((resi.att %*% resi.att) * (resj.att %*% resj.att))
}
}
#stretch between 0 and 1
for (i in 1:num.res) {
res.sim.low <- res.sim[,i] - min(res.sim[,i])
res.sim[,i] <- res.sim.low/max(res.sim.low)
}
res.sim
plot(as.numeric(res.sim))
plot(as.numeric(res.sim[,1]))
plot(as.numeric(res.sim[,2]))
plot(as.numeric(res.sim[,3]))
plot(as.numeric(res.sim[,4]))
plot(as.numeric(res.sim[,5]))
param.beta
dec.beta <- matrix(0,num.res,num.dec)
i = 1
res.sim[,i]
dnbeta(res.sim[,i],a=param.beta[i,1],b=param.beta[i,2])
?dbeta
dbeta(res.sim[,i],a=param.beta[i,1],b=param.beta[i,2])
dbeta(res.sim[1,i],a=param.beta[i,1],b=param.beta[i,2])
dbeta(res.sim[,i],shape1=param.beta[i,1],shape2=param.beta[i,2])
dec.beta <- matrix(0,num.res,num.dec)
for (i in 1:num.dec) {
dec.beta[,i] <- dbeta(res.sim[,i],shape1=param.beta[i,1],shape2=param.beta[i,2])
}
res.sim[,i]
i
num.dec
dec.beta
res.sim
dec.ls <- list()
for (j in 1:num.res) {
dec.beta <- matrix(0,num.res,num.dec)
for (i in 1:num.dec) {
dec.beta[,i] <- dbeta(res.sim[i,j],shape1=param.beta[i,1],shape2=param.beta[i,2])
}
dec.ls[[j]] <- dec.beta
}
res.sim
dec.beta
dec.ls <- list()
for (j in 1:num.res) {
dec.beta <- matrix(0,num.res,num.dec)
for (i in 1:num.dec) {
dec.beta[,i] <- dbeta(res.sim[,j],shape1=param.beta[i,1],shape2=param.beta[i,2])
}
dec.ls[[j]] <- dec.beta
}
decls[[1]]
dec.ls[[1]]
res.sim[,1]
plot(dec.ls[[1]][,1])
res.sim <- res.sim + 0.01
res.sim
#Resource similarity ~ cosine similarity index
res.sim <- matrix(0,num.res,num.res)
for (i in 1:num.res) {
for (j in 1:num.res) {
resi.att <- c(1,res.bs[i]) #in multidimensional trait space, this would be a vector of attributes
resj.att <- c(1,res.bs[j])
res.sim[i,j] <- (resi.att %*% resj.att)/ sqrt((resi.att %*% resi.att) * (resj.att %*% resj.att))
}
}
#stretch between 0 and 1 for each similarity column
for (i in 1:num.res) {
res.sim.low <- res.sim[,i] - (min(res.sim[,i]) + 0.01)
res.sim[,i] <- res.sim.low/max(res.sim.low)
}
res.sim
#Resource similarity ~ cosine similarity index
res.sim <- matrix(0,num.res,num.res)
for (i in 1:num.res) {
for (j in 1:num.res) {
resi.att <- c(1,res.bs[i]) #in multidimensional trait space, this would be a vector of attributes
resj.att <- c(1,res.bs[j])
res.sim[i,j] <- (resi.att %*% resj.att)/ sqrt((resi.att %*% resi.att) * (resj.att %*% resj.att))
}
}
#stretch between 0 and 1 for each similarity column
for (i in 1:num.res) {
res.sim.low <- res.sim[,i] - (min(res.sim[,i]) - 0.01)
res.sim[,i] <- res.sim.low/max(res.sim.low)
}
res.sim
#Resource similarity ~ cosine similarity index
res.sim <- matrix(0,num.res,num.res)
for (i in 1:num.res) {
for (j in 1:num.res) {
resi.att <- c(1,res.bs[i]) #in multidimensional trait space, this would be a vector of attributes
resj.att <- c(1,res.bs[j])
res.sim[i,j] <- (resi.att %*% resj.att)/ sqrt((resi.att %*% resi.att) * (resj.att %*% resj.att))
}
}
#stretch between 0 and 1 for each similarity column
for (i in 1:num.res) {
res.sim.low <- res.sim[,i] - (min(res.sim[,i]))
res.sim[,i] <- res.sim.low/max(res.sim.low)
}
res.sim
#Resource similarity ~ cosine similarity index
res.sim <- matrix(0,num.res,num.res)
for (i in 1:num.res) {
for (j in 1:num.res) {
resi.att <- c(1,res.bs[i]) #in multidimensional trait space, this would be a vector of attributes
resj.att <- c(1,res.bs[j])
res.sim[i,j] <- (resi.att %*% resj.att)/ sqrt((resi.att %*% resi.att) * (resj.att %*% resj.att))
}
}
#stretch between 0 and 1 for each similarity column
for (i in 1:num.res) {
res.sim.low <- res.sim[,i] - (min(res.sim[,i])) + 0.01
res.sim[,i] <- res.sim.low/max(res.sim.low)
}
res.sim
#Resource similarity ~ cosine similarity index
res.sim <- matrix(0,num.res,num.res)
for (i in 1:num.res) {
for (j in 1:num.res) {
resi.att <- c(1,res.bs[i]) #in multidimensional trait space, this would be a vector of attributes
resj.att <- c(1,res.bs[j])
res.sim[i,j] <- (resi.att %*% resj.att)/ sqrt((resi.att %*% resi.att) * (resj.att %*% resj.att))
}
}
#stretch between 0 and 1 for each similarity column
for (i in 1:num.res) {
res.sim.low <- res.sim[,i] - (min(res.sim[,i])) + 0.001
res.sim[,i] <- res.sim.low/max(res.sim.low)
}
res.sim
#Resource similarity ~ cosine similarity index
res.sim <- matrix(0,num.res,num.res)
for (i in 1:num.res) {
for (j in 1:num.res) {
resi.att <- c(1,res.bs[i]) #in multidimensional trait space, this would be a vector of attributes
resj.att <- c(1,res.bs[j])
res.sim[i,j] <- (resi.att %*% resj.att)/ sqrt((resi.att %*% resi.att) * (resj.att %*% resj.att))
}
}
#stretch between 0 and 1 for each similarity column
for (i in 1:num.res) {
res.sim.low <- res.sim[,i] - (min(res.sim[,i])) + 0.0001
res.sim[,i] <- res.sim.low/max(res.sim.low)
}
res.sim
#Build decision probabilities
dec.ls <- list()
for (j in 1:num.res) {
dec.beta <- matrix(0,num.res,num.dec)
for (i in 1:num.dec) {
dec.beta[,i] <- dbeta(res.sim[,j],shape1=param.beta[i,1],shape2=param.beta[i,2])
}
dec.ls[[j]] <- dec.beta
}
dec.ls[[1]]
res.sim <- res.sim - 0.0001
res.sim
#Build decision probabilities
dec.ls <- list()
for (j in 1:num.res) {
dec.beta <- matrix(0,num.res,num.dec)
for (i in 1:num.dec) {
dec.beta[,i] <- dbeta(res.sim[,j],shape1=param.beta[i,1],shape2=param.beta[i,2])
}
dec.ls[[j]] <- dec.beta
}
dec.ls[[1]]
round(dec.ls[[1]],3)
?dbeta
x <- seq(0, 1, length = 21)
x
dbeta(x, 1, 1)
pbeta(x, 1, 1)
pbeta(x, 1, 5)
dbeta(x, 1, 5)
plot(dbeta(x,1,1))
plot(dbeta(x,2,1))
plot(dbeta(x,3,1))
plot(dbeta(x,4,1))
plot(dbeta(x,5,1))
plot(dbeta(x,1,5))
#Resource similarity ~ cosine similarity index
res.sim <- matrix(0,num.res,num.res)
for (i in 1:num.res) {
for (j in 1:num.res) {
resi.att <- c(1,res.bs[i]) #in multidimensional trait space, this would be a vector of attributes
resj.att <- c(1,res.bs[j])
res.sim[i,j] <- (resi.att %*% resj.att)/ sqrt((resi.att %*% resi.att) * (resj.att %*% resj.att))
}
}
#stretch between 0 and 1 for each similarity column
for (i in 1:num.res) {
res.sim.low <- res.sim[,i] - (min(res.sim[,i]))
res.sim[,i] <- res.sim.low/max(res.sim.low)
}
#Build decision probabilities
dec.ls <- list()
for (j in 1:num.res) {
dec.beta <- matrix(0,num.res,num.dec)
for (i in 1:num.dec) {
dec.beta[,i] <- dbeta(res.sim[,j],shape1=param.beta[i,1],shape2=param.beta[i,2])
}
dec.ls[[j]] <- dec.beta
}
dec.beta
#Build decision probabilities
dec.ls <- list()
for (j in 1:num.res) {
dec.beta <- matrix(0,num.res,num.dec)
for (i in 1:num.dec) {
dec.beta[,i] <- dbeta(res.sim[,j],shape1=param.beta[i,1],shape2=param.beta[i,2])
}
#Normalize to sum to 1
dec.beta.n <- apply(dec.beta,2,function(x){x/sum(x)})
dec.ls[[j]] <- dec.beta.n
}
dec.ls[[1]]
sum(dec.ls[[1]][,1]
)
sum(dec.ls[[1]][,2])
plot(sort(dec.ls[[1]][,2]),type="l")
for (i in 2:10) {lines(sort(dec.ls[[1]][,i]),type="l")}
colors <- brewer.pal(10,"Set1")
display.brewer.all()
colors <- brewer.pal(10,"Spectral")
plot(sort(dec.ls[[1]][,2]),type="l",col=colors[1])
for (i in 2:10) {lines(sort(dec.ls[[1]][,i]),type="l"),col=colors[i]}
for (i in 2:10) {lines(sort(dec.ls[[1]][,i]),type="l",col=colors[i])}
#Build decision probabilities
dec.ls <- list()
for (j in 1:num.res) {
dec.beta <- matrix(0,num.res,num.dec)
for (i in 1:num.dec) {
dec.beta[,i] <- dbeta(res.sim[,j],shape1=param.beta[i,1],shape2=param.beta[i,2])
}
#Normalize to sum to 1
dec.beta.n <- apply(dec.beta,2,function(x){x/max(x)})
dec.ls[[j]] <- dec.beta.n
}
plot(sort(dec.ls[[1]][,2]),type="l",col=colors[1])
for (i in 2:10) {lines(sort(dec.ls[[1]][,i]),type="l",col=colors[i])}
#Build decision probabilities
dec.ls <- list()
for (j in 1:num.res) {
dec.beta <- matrix(0,num.res,num.dec)
for (i in 1:num.dec) {
dec.beta[,i] <- dbeta(res.sim[,j],shape1=param.beta[i,1],shape2=param.beta[i,2])
}
#Normalize to sum to 1
dec.beta.n <- apply(dec.beta,2,function(x){x/sum(x)})
dec.ls[[j]] <- dec.beta.n
}
plot(sort(dec.ls[[1]][,2]),type="l",col=colors[1])
for (i in 2:10) {lines(sort(dec.ls[[1]][,i]),type="l",col=colors[i])}
#Compute fitness matrices
dec.ls
param.beta
plot(dec.ls[[1]][,2],type="l",col=colors[1])
for (i in 2:10) {lines(dec.ls[[1]][,i],type="l",col=colors[i])}
