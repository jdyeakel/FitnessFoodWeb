Rout <- SDP_initialcond(
max.res.bs <- 1000,
num.res <- 20,
cons.bs <- 20,
tmax <- 80,
hab.het.var <- 0,
max.enc <- 20,
learn.mag <- 0)
Rout[[1]]
Rout[[2]]
#Run Backwards simulation
cout <- SDP_single(tmax = tmax,
res_bs = Rout[[1]],
cons_bs = cons.bs,
xc <- Rout[[2]],
rep_gain = Rout[[3]],
f_m = Rout[[4]],
mort = Rout[[5]],
dec_ls = Rout[[6]],
rho_vec = Rout[[7]],
c_learn = Rout[[8]],
g_forage = Rout[[9]],
c_forage = Rout[[10]]
)
W.nr <- cout[[1]]
istar.nr <- cout[[2]]
sourceCpp("src/SDP_single.cpp")
#Run Backwards simulation
cout <- SDP_single(tmax = tmax,
res_bs = Rout[[1]],
cons_bs = cons.bs,
xc <- Rout[[2]],
rep_gain = Rout[[3]],
f_m = Rout[[4]],
mort = Rout[[5]],
dec_ls = Rout[[6]],
rho_vec = Rout[[7]],
c_learn = Rout[[8]],
g_forage = Rout[[9]],
c_forage = Rout[[10]]
)
W.nr <- cout[[1]]
istar.nr <- cout[[2]]
time.stamp <- 1
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,Rout[[2]]-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(Rout[[2]], cons.bs, length.out = nrow(istar.node)),
Rout[[1]],
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
res.bs <- Rout[[1]]
xc <- Rout[[2]]
rep.gain <- Rout[[3]]
f.m <- Rout[[4]]
mort <- Rout[[5]]
dec.ls <- Rout[[6]]
rho.vec <- Rout[[7]]
c.learn <- Rout[[8]]
g.forage <- Rout[[9]]
c.forage <- Rout[[10]]
#Run Backwards simulation
cout <- SDP_single(tmax = tmax,
res_bs = res.bs,
cons_bs = cons.bs,
xc = xc,
rep_gain = rep.gain,
f_m = f.m,
mort = mort,
dec_ls = dec.ls,
rho_vec = rho.vec,
c_learn = c.learn,
g_forage = g.forage,
c_forage = c.forage
)
W.nr <- cout[[1]]
istar.nr <- cout[[2]]
time.stamp <- 1
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
time.stamp <- 1
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, cons.bs, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
source("R/SDP_initialcond.R")
#Initial Conditions
Rout <- SDP_initialcond(
max.res.bs <- 1000,
num.res <- 20,
cons.bs <- 20,
tmax <- 80,
hab.het.var <- 0,
max.enc <- 20,
learn.mag <- 0)
plot(seq(0,max.enc,1),Rout[[4]][,1],type="l",col=colors[1],lwd=3,ylim=c(0,max(Rout[[4]])))
for (i in 2:num.res) {
lines(seq(0,max.enc,1),Rout[[4]][,i],col=colors[i],lwd=3)
}
res.bs <- Rout[[1]]
xc <- Rout[[2]]
rep.gain <- Rout[[3]]
f.m <- Rout[[4]]
mort <- Rout[[5]]
dec.ls <- Rout[[6]]
rho.vec <- Rout[[7]]
c.learn <- Rout[[8]]
g.forage <- Rout[[9]]
c.forage <- Rout[[10]]
eta <- Rout[[11]]
eta
sourceCpp("src/SDP_single_foreq.cpp")
#Starting values
N <- 20 #starting Num. of individuals
tsim <- 1000 #Simulation time
r.alpha <- 3 #Recruit density-independent growth rate
r.beta <- 1/80 #Recruit density-dependent growth rate
r.comp <- 1 #degree of compensation
time.stamp <- 1
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, cons.bs, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
cout.foreq <- SDP_single_foreq(tmax,
res.bs,
cons.bs,
xc,
rep.gain,
f.m,
mort,
dec.ls,
rho.vec,
c.learn,
g.forage,
c.forage,
W.nr,
istar.nr,
N,
tsim,
r.alpha,
r.beta,
r.comp)
pop.traj <- cout.foreq[[1]]
x.traj <- cout.foreq[[2]]; x.mean <- unlist(lapply(x.traj,mean))
t.traj <- cout.foreq[[3]]; t.mean <- unlist(lapply(t.traj,mean))
d.traj <- cout.foreq[[4]]
trophic.traj <- cout.foreq[[5]]
fitness <- cout.foreq[[6]]; fit.mean <- unlist(lapply(fitness,mean))
cout.foreq <- SDP_single_foreq(tmax,
res.bs,
cons.bs,
xc,
rep.gain,
f.m,
mort,
dec.ls,
rho.vec,
c.learn,
g.forage,
c.forage,
W.nr,
istar.nr,
N,
tsim,
r.alpha,
r.beta,
r.comp)
tmax
res.bs
cons.bs
xc
rep.gain
f.m
mort
dec.ls
rho.vec
c.learn
g.forage
c.forage
W.nr
istar.nr
N
tsim
r.alpha
r.beta
r.comp
sourceCpp("src/SDP_single_foreq.cpp")
cout.foreq <- SDP_single_foreq(tmax,
res.bs,
cons.bs,
xc,
rep.gain,
f.m,
mort,
dec.ls,
rho.vec,
c.learn,
g.forage,
c.forage,
W.nr,
istar.nr,
N,
tsim,
r.alpha,
r.beta,
r.comp)
xc
as.numeric(xc)
cout.foreq <- SDP_single_foreq(tmax,
res.bs,
cons.bs,
xc,
rep.gain,
f.m,
mort,
dec.ls,
rho.vec,
c.learn,
g.forage,
c.forage,
W.nr,
istar.nr,
N,
tsim,
r.alpha,
r.beta,
r.comp)
cout.foreq <- SDP_single_foreq(tmax,
res.bs,
cons.bs,
xc,
rep.gain,
f.m,
mort,
dec.ls,
rho.vec,
c.learn,
g.forage,
c.forage,
W.nr,
istar.nr,
N,
tsim,
r.alpha,
r.beta,
r.comp
)
rm(list=c(ls()))
library(RColorBrewer)
library(Rcpp)
library(igraph)
library(beanplot)
library(lattice)
library(emdbook)
source("src/filled_contour.r")
source("src/smooth_pal.R")
colors <- brewer.pal(5,"Spectral")
colors <- smooth_pal(colors, 5)
source("R/SDP_initialcond.R")
sourceCpp("src/SDP_single.cpp")
sourceCpp("src/SDP_single_foreq.cpp")
#Initial Conditions
Rout <- SDP_initialcond(
max.res.bs <- 1000,
num.res <- 20,
cons.bs <- 20,
tmax <- 80,
hab.het.var <- 0,
max.enc <- 20,
learn.mag <- 0)
res.bs <- Rout[[1]]
xc <- Rout[[2]]
rep.gain <- Rout[[3]]
f.m <- Rout[[4]]
mort <- Rout[[5]]
dec.ls <- Rout[[6]]
rho.vec <- Rout[[7]]
c.learn <- Rout[[8]]
g.forage <- Rout[[9]]
c.forage <- Rout[[10]]
eta <- Rout[[11]]
#Run Backwards simulation
cout <- SDP_single(tmax = tmax,
res_bs = res.bs,
cons_bs = cons.bs,
xc = xc,
rep_gain = rep.gain,
f_m = f.m,
mort = mort,
dec_ls = dec.ls,
rho_vec = rho.vec,
c_learn = c.learn,
g_forage = g.forage,
c_forage = c.forage
)
W.nr <- cout[[1]]
istar.nr <- cout[[2]]
time.stamp <- 1
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, cons.bs, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
#Starting values
N <- 20 #starting Num. of individuals
tsim <- 1000 #Simulation time
r.alpha <- 3 #Recruit density-independent growth rate
r.beta <- 1/80 #Recruit density-dependent growth rate
r.comp <- 1 #degree of compensation
cout.foreq <- SDP_single_foreq(tmax = tmax,
res_bs = res.bs,
cons_bs = cons.bs,
xc = xc,
rep_gain = rep.gain,
f_m = f.m,
mort = mort,
dec_ls = dec.ls,
rho_vec = rho.vec,
c_learn = c.learn,
g_forage = g.forage,
c_forage = c.forage,
W_nr = W.nr,
istar_nr = istar.nr,
N_init = N,
tsim = tsim,
alpha = r.alpha,
beta = r.beta,
comp = r.comp
)
pop.traj <- cout.foreq[[1]]
x.traj <- cout.foreq[[2]]; x.mean <- unlist(lapply(x.traj,mean))
t.traj <- cout.foreq[[3]]; t.mean <- unlist(lapply(t.traj,mean))
d.traj <- cout.foreq[[4]]
trophic.traj <- cout.foreq[[5]]
fitness <- cout.foreq[[6]]; fit.mean <- unlist(lapply(fitness,mean))
plot(pop.traj,type="l")
r.alpha/r.beta
#Starting values
N <- 20 #starting Num. of individuals
tsim <- 1000 #Simulation time
r.alpha <- 2 #Recruit density-independent growth rate
r.beta <- 1/80 #Recruit density-dependent growth rate
r.comp <- 1 #degree of compensation
int tmax, NumericVector res_bs, int cons_bs, int xc, NumericVector rep_gain,
NumericMatrix f_m, NumericVector mort, List dec_ls, NumericVector rho_vec, NumericMatrix c_learn,
NumericVector g_forage, NumericVector c_forage, List W_nr, List istar_nr, int N_init, int tsim,
double alpha, double beta, double comp
cout.foreq <- SDP_single_foreq(tmax = tmax,
res_bs = res.bs,
cons_bs = cons.bs,
xc = xc,
rep_gain = rep.gain,
f_m = f.m,
mort = mort,
dec_ls = dec.ls,
rho_vec = rho.vec,
c_learn = c.learn,
g_forage = g.forage,
c_forage = c.forage,
W_nr = W.nr,
istar_nr = istar.nr,
N_init = N,
tsim = tsim,
alpha = r.alpha,
beta = r.beta,
comp = r.comp
)
plot(pop.traj,type="l")
plot(pop.traj,type="l")
#Starting values
N <- 20 #starting Num. of individuals
tsim <- 1000 #Simulation time
r.alpha <- 2 #Recruit density-independent growth rate
r.beta <- 1/80 #Recruit density-dependent growth rate
r.comp <- 1 #degree of compensation
int tmax, NumericVector res_bs, int cons_bs, int xc, NumericVector rep_gain,
NumericMatrix f_m, NumericVector mort, List dec_ls, NumericVector rho_vec, NumericMatrix c_learn,
NumericVector g_forage, NumericVector c_forage, List W_nr, List istar_nr, int N_init, int tsim,
double alpha, double beta, double comp
cout.foreq <- SDP_single_foreq(tmax = tmax,
res_bs = res.bs,
cons_bs = cons.bs,
xc = xc,
rep_gain = rep.gain,
f_m = f.m,
mort = mort,
dec_ls = dec.ls,
rho_vec = rho.vec,
c_learn = c.learn,
g_forage = g.forage,
c_forage = c.forage,
W_nr = W.nr,
istar_nr = istar.nr,
N_init = N,
tsim = tsim,
alpha = r.alpha,
beta = r.beta,
comp = r.comp
)
pop.traj <- cout.foreq[[1]]
x.traj <- cout.foreq[[2]]; x.mean <- unlist(lapply(x.traj,mean))
t.traj <- cout.foreq[[3]]; t.mean <- unlist(lapply(t.traj,mean))
d.traj <- cout.foreq[[4]]
trophic.traj <- cout.foreq[[5]]
fitness <- cout.foreq[[6]]; fit.mean <- unlist(lapply(fitness,mean))
plot(pop.traj,type="l")
r.alpha/r.beta
mean(pop.traj[500:1000])
plot(unlist(x.traj),unlist(fitness))
plot(unlist(fitness),unlist(x.traj))
plot(unlist(fitness),unlist(t.traj))
plot(unlist(fitness),unlist(d.traj))
d.traj
max(unlist(d.traj))
min(unlist(d.traj))
which(max(d.traj))
max(unlist(dec.ls))
dec.ls
unlist(istar.nr)
max(unlist(istar.nr))
res.bs
W.nr
istar.nr[[1]]
xc
plot(unlist(d.traj))
plot(unlist(d.traj),type="l")
d.traj[[10]]
d.traj[[11]]
d.traj[[12]]
d.traj[[13]]
d.traj[[14]]
d.traj[[15]]
d.traj[[16]]
d.traj[[17]]
d.traj[[18]]
d.traj[[50]]
d.traj[[56]]
d.traj[[100]]
d.traj[[200]]
d.traj[[210]]
d.traj[[209]]
d.traj[[211]]
plot(pop.traj,type="l")
trophic.v <- unlist(trophic.traj[1:tsim])
trophic.prop <- numeric(20)
for (i in 1:20) {
trophic.prop[i] <- length(which(trophic.v == i))/length(trophic.v)
}
plot(res.bs,trophic.prop)
plot(rep(1,length(trophic.traj[[1]])),trophic.traj[[1]],xlim=c(0,tsim),ylim=c(0,num.res),pch='.')
for (i in 2:tsim) {
points(rep(i,length(trophic.traj[[i]])),trophic.traj[[i]],pch='.')
}
plot(fit.mean,type="l")
plot(unlist(fitness),unlist(x.traj))
plot(unlist(fitness),unlist(t.traj))
plot(pop.traj,x.mean)
plot(pop.traj,t.mean)
plot(pop.traj[500:1000],t.mean[500:1000])
