}
# Plot probability that a consumer finds k items  of resource i
colors <- brewer.pal(10,"Spectral")
plot(seq(0,max_enc,1),f_vector[,1],type="l",ylim=c(0,max(f_vector)),col=colors[1],lwd=3)
for(i in 2:sp_rich) {
lines(seq(0,max_enc,1),f_vector[,i],col=colors[i],lwd=3)
}
W_x <- list()
istar <- list()
for (sp in 1:sp_rich) {
W_x[[sp]] <- matrix(0,sp_bs[sp],tmax_sp[sp])
istar[[sp]] <-  matrix(0,sp_bs[sp],(tmax_sp[sp]-1))
}
sp_bs
sp <- 1
xmax <- sp_bs[sp]
xmax
tmax <- tmax_sp[sp]
tmax
xc
xcrit <- xc[sp]
xcrit
51-32
res <- pot_foods[[sp]]
res
num_foods <- length(res)
num_foods
num_decisions <- num_foods*6 #number of foods * 2 (r/f) * 3 (low,med,high competition)
num_decisions
decisions <- matrix(0,num_decisions,4)
colnames(decisions) <- c("Resource","Comp","Rep","FValue")
decisions[,1] <- rep(unlist(lapply(res,function(x){rep(x,3)})),2)
decisions[,2] <- rep(rep(c(1,2,3),num_foods),2)
decisions[,3] <- c(rep(0,num_decisions/2),rep(1,num_decisions/2))
71*6
seq(1,50,1)*6
decisions
seq(tmax,1,-1)
seq((tmax-1),1,-1)
i = 1
t = 9
x = xcrit
value_max <- -10
d_i <- decisions[i,]
res_i <- as.numeric(d_i[1])
chi <- as.numeric(d_i[2])
rho <- as.numeric(d_i[3])
res_i
chi
rho
g_forage <- matrix(0,sp_rich,sp_rich)
c_forage <- numeric(0,sp_rich,sp_rich)
c_rep <- numeric(sp_rich)
for (i in 1:sp_rich) {
for (j in 1:sp_rich) {
#Foraging costs/gains conditional on consumer AND resource
eta[i,j] <- 1
#Gains/costs scale with prob of interaction
p <- exp(a1 + a2*log(sp_bs[i]/sp_bs[j]) + a3*log(sp_bs[i]/sp_bs[j])^2)
g_forage[i,j] <- (p/(1+p)) * sp_bs[j]
c_forage[i,j] <- (p/(1+p)) * sp_bs[j]
}
#Reproductive costs conditional only on consumer
c_rep[i] <- 0.10*sp_bs[i]
}
#Foraging Gains and Costs (allometric and stoichiometric)
eta <- matrix(0,sp_rich,sp_rich)
g_forage <- matrix(0,sp_rich,sp_rich)
c_forage <- numeric(0,sp_rich,sp_rich)
c_rep <- numeric(sp_rich)
for (i in 1:sp_rich) {
for (j in 1:sp_rich) {
#Foraging costs/gains conditional on consumer AND resource
eta[i,j] <- 1
#Gains/costs scale with prob of interaction
p <- exp(a1 + a2*log(sp_bs[i]/sp_bs[j]) + a3*log(sp_bs[i]/sp_bs[j])^2)
g_forage[i,j] <- (p/(1+p)) * sp_bs[j]
c_forage[i,j] <- (p/(1+p)) * sp_bs[j]
}
#Reproductive costs conditional only on consumer
c_rep[i] <- 0.10*sp_bs[i]
}
#Foraging Gains and Costs (allometric and stoichiometric)
eta <- matrix(0,sp_rich,sp_rich)
g_forage <- matrix(0,sp_rich,sp_rich)
c_forage <- matrix(0,sp_rich,sp_rich)
c_rep <- numeric(sp_rich)
for (i in 1:sp_rich) {
for (j in 1:sp_rich) {
#Foraging costs/gains conditional on consumer AND resource
eta[i,j] <- 1
#Gains/costs scale with prob of interaction
p <- exp(a1 + a2*log(sp_bs[i]/sp_bs[j]) + a3*log(sp_bs[i]/sp_bs[j])^2)
g_forage[i,j] <- (p/(1+p)) * sp_bs[j]
c_forage[i,j] <- (p/(1+p)) * sp_bs[j]
}
#Reproductive costs conditional only on consumer
c_rep[i] <- 0.10*sp_bs[i]
}
eta
g_forage
eta <- matrix(0,sp_rich,sp_rich)
g_forage <- matrix(0,sp_rich,sp_rich)
c_forage <- matrix(0,sp_rich,sp_rich)
c_rep <- numeric(sp_rich)
for (i in 1:sp_rich) {
for (j in 1:sp_rich) {
#Foraging costs/gains conditional on consumer AND resource
eta[i,j] <- 1
#Gains/costs scale with prob of interaction
p <- exp(a1 + a2*log(sp_bs[i]/sp_bs[j]) + a3*log(sp_bs[i]/sp_bs[j])^2)
g_forage[i,j] <- (p/(1+p)) * sp_bs[j]/10
c_forage[i,j] <- (p/(1+p)) * sp_bs[j]/10
}
#Reproductive costs conditional only on consumer
c_rep[i] <- 0.10*sp_bs[i]
}
g_forage
eta <- matrix(0,sp_rich,sp_rich)
g_forage <- matrix(0,sp_rich,sp_rich)
c_forage <- matrix(0,sp_rich,sp_rich)
c_rep <- numeric(sp_rich)
for (i in 1:sp_rich) {
for (j in 1:sp_rich) {
#Foraging costs/gains conditional on consumer AND resource
eta[i,j] <- 1
#Gains/costs scale with prob of interaction
p <- exp(a1 + a2*log(sp_bs[i]/sp_bs[j]) + a3*log(sp_bs[i]/sp_bs[j])^2)
g_forage[i,j] <- (p/(1+p)) * sp_bs[j]/20
c_forage[i,j] <- (p/(1+p)) * sp_bs[j]/20
}
#Reproductive costs conditional only on consumer
c_rep[i] <- 0.10*sp_bs[i]
}
g_forage
c_forage
c_rep
#Foraging Gains and Costs (allometric and stoichiometric)
eta <- matrix(0,sp_rich,sp_rich)
g_forage <- matrix(0,sp_rich,sp_rich)
c_forage <- matrix(0,sp_rich,sp_rich)
c_rep <- numeric(sp_rich)
for (i in 1:sp_rich) {
for (j in 1:sp_rich) {
#Foraging costs/gains conditional on consumer AND resource
eta[i,j] <- 1
#Gains/costs scale with prob of interaction
p <- exp(a1 + a2*log(sp_bs[i]/sp_bs[j]) + a3*log(sp_bs[i]/sp_bs[j])^2)
g_forage[i,j] <- (p/(1+p)) * sp_bs[j]/20
c_forage[i,j] <- (p/(1+p)) * sp_bs[j]/20
}
#Reproductive costs conditional only on consumer
c_rep[i] <- 0.05*sp_bs[i]
}
c_rep
g_forage
x
eta[sp,res_i]
#Foraging Gains and Costs (allometric and stoichiometric)
eta <- matrix(0,sp_rich,sp_rich)
g_forage <- matrix(0,sp_rich,sp_rich)
c_forage <- matrix(0,sp_rich,sp_rich)
c_rep <- numeric(sp_rich)
for (i in 1:sp_rich) {
for (j in 1:sp_rich) {
#Foraging costs/gains conditional on consumer AND resource
eta[i,j] <- 0.5
#Gains/costs scale with prob of interaction
p <- exp(a1 + a2*log(sp_bs[i]/sp_bs[j]) + a3*log(sp_bs[i]/sp_bs[j])^2)
g_forage[i,j] <- (p/(1+p)) * sp_bs[j]/20
c_forage[i,j] <- (p/(1+p)) * sp_bs[j]/20
}
#Reproductive costs conditional only on consumer
c_rep[i] <- 0.05*sp_bs[i]
}
eta[sp,res_i]
g_forage[sp,res_i]
k
chi
c_forage[sp,res_i]
x + min((eta[sp,res_i]*g_forage[sp,res_i]*k)/chi, xs)
- c_forage[sp,res_i]*chi - rho*c_rep[sp]
#DYNAMICS
xp <- numeric(max_enc+1)
tic <- 0
for (k in 0:max_enc) {
tic <- tic + 1
xp[tic] <- x + min((eta[sp,res_i]*g_forage[sp,res_i]*k)/chi, xs)
- c_forage[sp,res_i]*chi - rho*c_rep[sp]
}
xs <- 100
#DYNAMICS
xp <- numeric(max_enc+1)
tic <- 0
for (k in 0:max_enc) {
tic <- tic + 1
xp[tic] <- x + min((eta[sp,res_i]*g_forage[sp,res_i]*k)/chi, xs)
- c_forage[sp,res_i]*chi - rho*c_rep[sp]
}
xp
x
c_rep
rho = 1
xp <- numeric(max_enc+1)
tic <- 0
for (k in 0:max_enc) {
tic <- tic + 1
xp[tic] <- x + min((eta[sp,res_i]*g_forage[sp,res_i]*k)/chi, xs)
- c_forage[sp,res_i]*chi - rho*c_rep[sp]
}
xp
xp <- numeric(max_enc+1)
tic <- 0
for (k in 0:max_enc) {
tic <- tic + 1
xp[tic] <- x + min((eta[sp,res_i]*g_forage[sp,res_i]*k)/chi, xs)
#- c_forage[sp,res_i]*chi - rho*c_rep[sp]
}
xp
xp <- numeric(max_enc+1)
tic <- 0
for (k in 0:max_enc) {
tic <- tic + 1
xp[tic] <- x + min((eta[sp,res_i]*g_forage[sp,res_i]*k)/chi, xs) -
c_forage[sp,res_i]*chi - rho*c_rep[sp]
}
xp
rho = 0
xp <- numeric(max_enc+1)
tic <- 0
for (k in 0:max_enc) {
tic <- tic + 1
xp[tic] <- x + min((eta[sp,res_i]*g_forage[sp,res_i]*k)/chi, xs) -
c_forage[sp,res_i]*chi - rho*c_rep[sp]
}
sp
xp
chi
chi = 2
xp <- numeric(max_enc+1)
tic <- 0
for (k in 0:max_enc) {
tic <- tic + 1
xp[tic] <- x + min((eta[sp,res_i]*g_forage[sp,res_i]*k)/chi, xs) -
c_forage[sp,res_i]*chi - rho*c_rep[sp]
}
xp
chi = 3
xp <- numeric(max_enc+1)
tic <- 0
for (k in 0:max_enc) {
tic <- tic + 1
xp[tic] <- x + min((eta[sp,res_i]*g_forage[sp,res_i]*k)/chi, xs) -
c_forage[sp,res_i]*chi - rho*c_rep[sp]
}
xp
xp
xp
plot(xp)
chi = 1
xp <- numeric(max_enc+1)
tic <- 0
for (k in 0:max_enc) {
tic <- tic + 1
xp[tic] <- x + min((eta[sp,res_i]*g_forage[sp,res_i]*k)/chi, xs) -
c_forage[sp,res_i]*chi - rho*c_rep[sp]
}
plot(xp)
chi = 2
xp <- numeric(max_enc+1)
tic <- 0
for (k in 0:max_enc) {
tic <- tic + 1
xp[tic] <- x + min((eta[sp,res_i]*g_forage[sp,res_i]*k)/chi, xs) -
c_forage[sp,res_i]*chi - rho*c_rep[sp]
}
points(xp)
chi = 3
xp <- numeric(max_enc+1)
tic <- 0
for (k in 0:max_enc) {
tic <- tic + 1
xp[tic] <- x + min((eta[sp,res_i]*g_forage[sp,res_i]*k)/chi, xs) -
c_forage[sp,res_i]*chi - rho*c_rep[sp]
}
points(xp)
x
decisions
choose(10,3)
perm(10,3)
choose(10,3)
choose(10,1)
choose(10,2)
#Mean encounter rate
xi <- 1/sp_bs * 100 #The bigger the species, the more rare it is
#Dispersion parameter... Larger = less patchy. Smaller = more patchy.
nu <- 1/sp_bs * 100 #The bigger the species, the more patchy it is... currently unbounded
max_enc <- 20
f_vector <- matrix(0,max_enc+1,sp_rich)
for (i in 1:sp_rich) {
for (j in 0:max_enc) {
f_vector[j,i] <- dnbinom(j,mu = xi[i], size = nu[i])
}
f_vector[,i] <- f_vector[,i] / sum(f_vector[,i])
}
# Plot probability that a consumer finds k items  of resource i
colors <- brewer.pal(10,"Spectral")
plot(seq(0,max_enc,1),f_vector[,1],type="l",ylim=c(0,max(f_vector)),col=colors[1],lwd=3)
for(i in 2:sp_rich) {
lines(seq(0,max_enc,1),f_vector[,i],col=colors[i],lwd=3)
}
combbn
combb
combn
?combn
combn(10,3)
combn(3,10)
combn(10,3)
choose(10,3)
combn(30,10)
choose(30,10)
library(RColorBrewer)
###################
# Community Metrics
###################
#Establish Species richness
sp_rich <- 10
#Establish species body sizes from a body size distribution
bs_mu <- 50 # Body size mean
bs_sd <- 10 # Body size standard deviation
sp_bs <- round(rnorm(sp_rich,bs_mu,bs_sd),0)
#Define interaction probability for each species
int_matrix <- matrix(0,sp_rich,sp_rich)
a1 <- 1.41
a2 <- 3.73
a3 <- -1.87
for (i in 1:sp_rich) {
for (j in 1:sp_rich) {
p <- exp(a1 + a2*log(sp_bs[i]/sp_bs[j]) + a3*log(sp_bs[i]/sp_bs[j])^2)
int_matrix[i,j] <- p / (1 + p)
}
}
#Establish potential foods for each species
pot_foods <- list()
cutoff <- 0.7 #probability cutoff for determining potential foods
for (i in 1:sp_rich) {
pot_foods[[i]] <- which(int_matrix[i,] > cutoff)
}
#Define state matrices for each species
tmax_sp <- rep(10,sp_rich)
state_matrix <- list()
for (i in 1:sp_rich) {
state_matrix[[i]] <- matrix(0,sp_bs[i],tmax_sp[i])
}
#Define critical threshold for each species
xc <- round((5/8)*sp_bs,0)
#Define terminal fitness function
#Currently just a increasing function with respect to x... NEED REFINED
for (i in 1:sp_rich) {
for (j in xc[i]:sp_bs[i]) {
state_matrix[[i]][j,tmax_sp[i]] <- j/sp_bs[i]
}
}
####################################
# Define Properties of the resources
####################################
#Mean encounter rate
xi <- 1/sp_bs * 100 #The bigger the species, the more rare it is
#Dispersion parameter... Larger = less patchy. Smaller = more patchy.
nu <- 1/sp_bs * 100 #The bigger the species, the more patchy it is... currently unbounded
max_enc <- 20
f_vector <- matrix(0,max_enc+1,sp_rich)
for (i in 1:sp_rich) {
for (j in 0:max_enc) {
f_vector[j,i] <- dnbinom(j,mu = xi[i], size = nu[i])
}
f_vector[,i] <- f_vector[,i] / sum(f_vector[,i])
}
# Plot probability that a consumer finds k items  of resource i
colors <- brewer.pal(10,"Spectral")
plot(seq(0,max_enc,1),f_vector[,1],type="l",ylim=c(0,max(f_vector)),col=colors[1],lwd=3)
for(i in 2:sp_rich) {
lines(seq(0,max_enc,1),f_vector[,i],col=colors[i],lwd=3)
}
library(RColorBrewer)
###################
# Community Metrics
###################
#Establish Species richness
sp_rich <- 10
#Establish species body sizes from a body size distribution
bs_mu <- 50 # Body size mean
bs_sd <- 10 # Body size standard deviation
sp_bs <- round(rnorm(sp_rich,bs_mu,bs_sd),0)
#Define interaction probability for each species
int_matrix <- matrix(0,sp_rich,sp_rich)
a1 <- 1.41
a2 <- 3.73
a3 <- -1.87
for (i in 1:sp_rich) {
for (j in 1:sp_rich) {
p <- exp(a1 + a2*log(sp_bs[i]/sp_bs[j]) + a3*log(sp_bs[i]/sp_bs[j])^2)
int_matrix[i,j] <- p / (1 + p)
}
}
#Establish potential foods for each species
pot_foods <- list()
cutoff <- 0.7 #probability cutoff for determining potential foods
for (i in 1:sp_rich) {
pot_foods[[i]] <- which(int_matrix[i,] > cutoff)
}
#Define state matrices for each species
tmax_sp <- rep(10,sp_rich)
state_matrix <- list()
for (i in 1:sp_rich) {
state_matrix[[i]] <- matrix(0,sp_bs[i],tmax_sp[i])
}
#Define critical threshold for each species
xc <- round((5/8)*sp_bs,0)
#Define terminal fitness function
#Currently just a increasing function with respect to x... NEED REFINED
for (i in 1:sp_rich) {
for (j in xc[i]:sp_bs[i]) {
state_matrix[[i]][j,tmax_sp[i]] <- j/sp_bs[i]
}
}
####################################
# Define Properties of the resources
####################################
#Mean encounter rate
xi <- 1/sp_bs * 100 #The bigger the species, the more rare it is
#Dispersion parameter... Larger = less patchy. Smaller = more patchy.
nu <- 1/sp_bs * 100 #The bigger the species, the more patchy it is... currently unbounded
max_enc <- 20
f_vector <- matrix(0,max_enc+1,sp_rich)
for (i in 1:sp_rich) {
for (j in 0:max_enc) {
f_vector[j,i] <- dnbinom(j,mu = xi[i], size = nu[i])
}
f_vector[,i] <- f_vector[,i] / sum(f_vector[,i])
}
# Plot probability that a consumer finds k items  of resource i
colors <- brewer.pal(10,"Spectral")
plot(seq(0,max_enc,1),f_vector[,1],type="l",ylim=c(0,max(f_vector)),col=colors[1],lwd=3)
for(i in 2:sp_rich) {
lines(seq(0,max_enc,1),f_vector[,i],col=colors[i],lwd=3)
}
pr_cons <- matrix(0,max_enc+1,sp_rich)
for (i in 1:sp_rich) {
for (j in 0:max_enc) {
pr_cons[j,i] <- 1 - exp(-j^2/max_enc)
}
}
colors <- brewer.pal(10,"Spectral")
plot(seq(0,max_enc,1),pr_cons[,1],type="l",ylim=c(0,max(f_vector)),col=colors[1],lwd=3)
for(i in 2:sp_rich) {
lines(seq(0,max_enc,1),pr_cons[,i],col=colors[i],lwd=3)
}
colors <- brewer.pal(10,"Spectral")
plot(seq(0,max_enc,1),pr_cons[,1],type="l",ylim=c(0,1),col=colors[1],lwd=3)
for(i in 2:sp_rich) {
lines(seq(0,max_enc,1),pr_cons[,i],col=colors[i],lwd=3)
}
colors <- brewer.pal(10,"Spectral")
plot(seq(0,max_enc,1),f_vector[,1],type="l",ylim=c(0,max(f_vector)),col=colors[1],lwd=3)
for(i in 2:sp_rich) {
lines(seq(0,max_enc,1),f_vector[,i],col=colors[i],lwd=3)
}
f_vector
1 - exp(-0^2/20)
1 - exp(-20^2/20)
apply(f_vector,2,sum)
nu
xi <- 1/sp_bs * 100 #The bigger the species, the more rare it is
#Dispersion parameter... Larger = less patchy. Smaller = more patchy.
nu <- -1/sp_bs * 100 #The bigger the species, the more patchy it is... currently unbounded
max_enc <- 20
f_vector <- matrix(0,max_enc+1,sp_rich)
for (i in 1:sp_rich) {
for (j in 0:max_enc) {
f_vector[j,i] <- dnbinom(j,mu = xi[i], size = nu[i])
}
f_vector[,i] <- f_vector[,i] / sum(f_vector[,i])
}
# Plot probability that a consumer finds k items  of resource i
colors <- brewer.pal(10,"Spectral")
plot(seq(0,max_enc,1),f_vector[,1],type="l",ylim=c(0,max(f_vector)),col=colors[1],lwd=3)
for(i in 2:sp_rich) {
lines(seq(0,max_enc,1),f_vector[,i],col=colors[i],lwd=3)
}
#Mean encounter rate
xi <- 1/sp_bs * 100 #The bigger the species, the more rare it is
#Dispersion parameter... Larger = less patchy. Smaller = more patchy.
nu <- 1/sp_bs * 100 #The bigger the species, the more patchy it is... currently unbounded
max_enc <- 20
f_vector <- matrix(0,max_enc+1,sp_rich)
for (i in 1:sp_rich) {
for (j in 0:max_enc) {
f_vector[j,i] <- dnbinom(j,mu = xi[i], size = nu[i])
}
f_vector[,i] <- f_vector[,i] / sum(f_vector[,i])
}
# Plot probability that a consumer finds k items  of resource i
colors <- brewer.pal(10,"Spectral")
plot(seq(0,max_enc,1),f_vector[,1],type="l",ylim=c(0,max(f_vector)),col=colors[1],lwd=3)
for(i in 2:sp_rich) {
lines(seq(0,max_enc,1),f_vector[,i],col=colors[i],lwd=3)
}
var <- xi + (xi^2/nu)
var
xi
var > xi
