#           }
#         }
#         #q*xp.low + (1-q)*xp.high ;; if q is 1, all weight on xp.low; vice versa
#Apply probabilities of finding k resources
Wk <- numeric(num.res)
for (rr in 1:num.res) {
Wk[rr] <- W[,rr] %*% f.m[,rr]
}
Fx <- as.numeric(pref.vec %*% (rep.gain[x] + (1-mort)*Wk))
value[i] <- Fx
}#end decision loop
#What is the fitness-maximizing decision?
max.value <- which(value == max(value))
#Is there more than one? I hope not!
if (length(max.value) > 1) {
print(paste(">1 at r=",r,"x=",x,"t=",t,sep=""))
istar.nr[[r]][x,t] <- 0
#I don't know if this is legit...
#it would assume that the organism would randomly choose a maximization strategy
#and I don't know what istar would then be
W.nr[[r]][x,t] <- mean(value[max.value])
} else {
#Record the fitness-maximizing decision
istar.nr[[r]][x,t] <- max.value
#Record the maximum fitness in the fitness matrix
W.nr[[r]][x,t] <- value[max.value]
}
}#end energetic state loop
}#end time loop
}#end current resource loop
#Time-invariant analysis
time.stamp <- 1
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
time.stamp <- 19
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
time.stamp <- 1
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
D12 <- numeric(tmax-1)
for (t in 1:tmax-1) {
D1 <- do.call(cbind,lapply(istar.nr,function(x){x[,t]}))
D2 <- do.call(cbind,lapply(istar.nr,function(x){x[,t+1]}))
D12[t] <- sum((D1 - D2)^2)
}
D1
D12 <- numeric(tmax-1)
for (t in 1:tmax-2) {
D1 <- do.call(cbind,lapply(istar.nr,function(x){x[,t]}))
D2 <- do.call(cbind,lapply(istar.nr,function(x){x[,t+1]}))
D12[t] <- sum((D1 - D2)^2)
}
D12
t
D12 <- numeric(tmax-1)
for (t in 1:(tmax-2)) {
D1 <- do.call(cbind,lapply(istar.nr,function(x){x[,t]}))
D2 <- do.call(cbind,lapply(istar.nr,function(x){x[,t+1]}))
D12[t] <- sum((D1 - D2)^2)
}
plot(D12)
plot(D12,type="l")
D1 - D2
(D1 - D2)^2
D12 <- numeric(tmax-1)
for (t in 1:(tmax-2)) {
D1 <- do.call(cbind,lapply(istar.nr,function(x){x[,t]}))
D2 <- do.call(cbind,lapply(istar.nr,function(x){x[,t+1]}))
D12[t] <- sqrt(sum((D1 - D2)^2))
}
plot(D12,type="b")
time.stamp <- 1
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
time.stamp <- 2
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
time.stamp <- 3
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
time.stamp <- 4
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
time.stamp <- 5
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
time.stamp <- 6
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
time.stamp <- 7
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
time.stamp <- 8
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
time.stamp <- 9
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
time.stamp <- 10
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
time.stamp <- 11
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
time.stamp <- 19
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
istar.node
time.stamp <- 1
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
rr <- seq(1,num.res)
rr
g.forage[rr]
x + rho.vec*(g.forage[rr] - (c.forage[rr] + c.learn[r,rr])) - (1-rho.vec)*(c.forage[rr] + c.learn[r,rr])
c.learn[r,rr]
(1-rho.vec)*(c.forage[rr] + c.learn[r,rr])
c.forage[rr]
c.forage[rr] + c.learn[r,rr]
length(c.forage[rr] + c.learn[r,rr])
(1-rho.vec)
length(rho.vec)
(g.forage[rr] - (c.forage[rr] + c.learn[r,rr]))
time.stamp <- 1
istar.node <- do.call(cbind,lapply(istar.nr,function(x){x[,time.stamp]}))
#Eliminate the <xc rows
istar.node <- istar.node[-seq(1,xc-1,1),]
col <- RColorBrewer::brewer.pal(6, "Spectral")
col <- rev(smooth_pal(col, 4))
op <- par(mfrow = c(1,1),
oma = c(6,6,0,0) + 0.1,
mar = c(0,0,1,1) + 0.1,
mgp = c(2, 1, 0))
filled_contour(seq(xc, xmax, length.out = nrow(istar.node)),
res.bs,
istar.node,
levels = seq(1, max(istar.node)),col = col,
lwd = 0.1,xlab="Energetic Reserves",ylab="Resource Size")
par(op)
rep.gain
f.m
cppFunction('
NumericVector backit(NumericVector x) {
l = x.size();
NumericVector y(l);
int tic = 0;
for (int i<l; i=0; i--) {
y(tic) = x(i);
tic = tic + 1;
}
NumericVector output = y;
return output;
}
')
cppFunction('
NumericVector backit(NumericVector x) {
int l = x.size();
NumericVector y(l);
int tic = 0;
for (int i<l; i=0; i--) {
y(tic) = x(i);
tic = tic + 1;
}
NumericVector output = y;
return output;
}
')
cppFunction('
NumericVector backit(NumericVector x) {
int l = x.size();
NumericVector y(l);
int tic = 0;
for (int i=l; i --> 0;) {
y(tic) = x(i);
tic = tic + 1;
}
NumericVector output = y;
return output;
}
')
backit(seq(1,10))
length(dec_ls)
length(dec.ls)
dec.c[,1]
dec.m[,1]
length(dec.m[,1])
f.m
length(rho.vec)
rho.vec
cppFunction('
double intpart(double x) {
double y = modf(x,&intpart);
return y
}
')
cppFunction('
double intpart(double x) {
double y = modf(x,&intpart);
return y;
}
')
#Grab integer component
cppFunction('
double intpart(double x) {
#include <math.h>       /* modf */
double y = modf(x,&intpart);
return y;
}
')
cppFunction('
#include <math.h>       /* modf */
double intpart(double x) {
double y = modf(x,&intpart);
return y;
}
')
cppFunction('
#include #include <cppHeaders/math.h>       /* modf */
double intpart(double x) {
double y = modf(x,&intpart);
return y;
}
')
#Grab integer component
cppFunction('
#include <cppHeaders/math.h>       /* modf */
double intpart(double x) {
double y = modf(x,&intpart);
return y;
}
')
#Grab integer component
cppFunction('
double intpart(double x) {
double y = floor(x);
return y;
}
')
intpart(3.14)
intpart(3.14987543987538r)
intpart(3.14987543987538)
cppFunction('
List changelist(List x) {
int l = x.size();
for (int i=0;i<l;i++) {
x[i](1,1) = x[i](1,1) + 1;
}
return x
}
')
cppFunction('
List changelist(List x) {
int l = x.size();
for (int i=0;i<l;i++) {
x[i](1,1) = x[i](1,1) + 1;
}
return x;
}
')
cppFunction('
List changelist(List x) {
int l = x.size();
for (int i=0;i<l;i++) {
x(i)(1,1) = x(i)(1,1) + 1;
}
return x;
}
')
cppFunction('
List changelist(List x) {
int l = x.size();
for (int i=0;i<l;i++) {
NumericMatrix m = x[i];
m(1,1) = m(1,1) + 1;
x[i] = m;
}
return x;
}
')
mlist = list()
mlist[[1]] <- matrix(1,5,5)
mlist[[2]] <- matrix(2,5,5)
changelist(mlist)
f.m
pref.vec
display.brewer.all()
library(RColorBrewer)
display.brewer.all()
colors <- brewer.pal(3,"Set1")
colors
colors <- brewer.pal(12,"RdYwBu")
colors <- brewer.pal(12,"RdYeBu")
colors <- brewer.pal(12,"RdYlBu")
colors <- brewer.pal(11,"RdYlBu")
colors[8]
colors[9]
colors <- brewer.pal(11,"RdYlGn")
colors[10]
colors[11]
colors <- brewer.pal(11,"BrBG")
colors[1]
colors <- brewer.pal(8,"Accent")
colors[5]
