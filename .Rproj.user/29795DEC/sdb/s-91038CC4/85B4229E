{
    "contents" : "\nlibrary(RColorBrewer)\n\n###################\n# Community Metrics\n###################\n\n#Establish Species richness\nsp_rich <- 10\n\n#Establish species body sizes from a body size distribution\nbs_mu <- 50 # Body size mean\nbs_sd <- 10 # Body size standard deviation\nsp_bs <- round(rnorm(sp_rich,bs_mu,bs_sd),0)\n\n#Define interaction probability for each species\nint_matrix <- matrix(0,sp_rich,sp_rich)\na1 <- 1.41\na2 <- 3.73\na3 <- -1.87\nfor (i in 1:sp_rich) {\n  for (j in 1:sp_rich) {\n    p <- exp(a1 + a2*log(sp_bs[i]/sp_bs[j]) + a3*log(sp_bs[i]/sp_bs[j])^2)\n    int_matrix[i,j] <- p / (1 + p)\n  }\n}\n\n#Establish potential foods for each species\npot_foods <- list()\ncutoff <- 0.7 #probability cutoff for determining potential foods\nfor (i in 1:sp_rich) {\n  pot_foods[[i]] <- which(int_matrix[i,] > cutoff)\n}\n\n#Define state matrices for each species\ntmax_sp <- rep(10,sp_rich)\nstate_matrix <- list()\nfor (i in 1:sp_rich) {\n  state_matrix[[i]] <- matrix(0,sp_bs[i],tmax_sp[i])\n}\n#Define critical threshold for each species\nxc <- round((5/8)*sp_bs,0)\n\n#Define terminal fitness function\n#Currently just a increasing function with respect to x... NEED REFINED\nfor (i in 1:sp_rich) {\n  for (j in xc[i]:sp_bs[i]) {\n    state_matrix[[i]][j,tmax_sp[i]] <- j/sp_bs[i]\n  }\n}\n\n####################################\n# Define Properties of the resources\n####################################\n\n#Mean encounter rate\nxi <- 1/sp_bs * 100 #The bigger the species, the more rare it is\n#Dispersion parameter... Larger = less patchy. Smaller = more patchy.\nnu <- 1/sp_bs * 100 #The bigger the species, the more patchy it is... currently unbounded\nmax_enc <- 20\nf_vector <- matrix(0,max_enc+1,sp_rich)\nfor (i in 1:sp_rich) {\n  for (j in 0:max_enc) {\n    f_vector[j,i] <- dnbinom(j,mu = xi[i], size = nu[i])\n  }\n  f_vector[,i] <- f_vector[,i] / sum(f_vector[,i])\n}\n# Plot probability that a consumer finds k items  of resource i\ncolors <- brewer.pal(10,\"Spectral\")\nplot(seq(0,max_enc,1),f_vector[,1],type=\"l\",ylim=c(0,max(f_vector)),col=colors[1],lwd=3)\nfor(i in 2:sp_rich) {\n  lines(seq(0,max_enc,1),f_vector[,i],col=colors[i],lwd=3)\n} \n\n#Consumer Resource mortalities (per-encounter mortalities)\nmort <- matrix(0,sp_rich,sp_rich)\n#What does probability of mortality equal when R/C ratio is 1?\nmp1 <- 0.1\nfor (i in 1:sp_rich) {\n  for (j in 1:sp_rich) {\n    #Consumer i foraging on Resource j\n    #Ratio of Resource to Consumer body size\n    Ratio_RC <- sp_bs[j] / sp_bs[i]\n    mort[j,i] <- 0.5 - 0.5*(1 - 2*mp1)^(Ratio_RC^2)\n  }\n}\n\n#Foraging Gains and Costs (allometric and stoichiometric)\neta <- matrix(0,sp_rich,sp_rich)\ng_forage <- matrix(0,sp_rich,sp_rich)\nc_forage <- matrix(0,sp_rich,sp_rich)\nc_rep <- numeric(sp_rich)\nfor (i in 1:sp_rich) {\n  for (j in 1:sp_rich) {\n    #Foraging costs/gains conditional on consumer AND resource\n    eta[i,j] <- 0.5\n    #Gains/costs scale with prob of interaction\n    p <- exp(a1 + a2*log(sp_bs[i]/sp_bs[j]) + a3*log(sp_bs[i]/sp_bs[j])^2)\n    g_forage[i,j] <- (p/(1+p)) * sp_bs[j]/20\n    c_forage[i,j] <- (p/(1+p)) * sp_bs[j]/20\n  }\n  #Reproductive costs conditional only on consumer\n  c_rep[i] <- 0.05*sp_bs[i]\n}\n\n##########################\n# Build Fitness Matrices\n##########################\nW_x <- list()\nistar <- list()\nfor (sp in 1:sp_rich) {\n  W_x[[sp]] <- matrix(0,sp_bs[sp],tmax_sp[sp])\n  istar[[sp]] <-  matrix(0,sp_bs[sp],(tmax_sp[sp]-1))\n}\n\n\n\n\nfor (sp in 1:sp_rich) {\n  #Maximum energetic reserves\n  xmax <- sp_bs[sp]\n  #Minimum energetic reserves\n  xcrit <- xc[sp]\n  #Stomach capacity (max amt consumed in one 'temporal window')\n  xs <- 100\n  tmax <- tmax_sp[sp]\n  \n  res <- pot_foods[[sp]]\n  num_foods <- length(res)\n  num_decisions <- num_foods*6 #number of foods * 2 (r/f) * 3 (low,med,high competition)\n  \n  decisions <- matrix(0,num_decisions,4)\n  colnames(decisions) <- c(\"Resource\",\"Comp\",\"Rep\",\"FValue\")\n  decisions[,1] <- rep(unlist(lapply(res,function(x){rep(x,3)})),2)\n  decisions[,2] <- rep(rep(c(1,2,3),num_foods),2)\n  decisions[,3] <- c(rep(0,num_decisions/2),rep(1,num_decisions/2))\n  \n  comp_vector <- rep(c(1,2,3),num_foods)\n  rep_vector <- rep(c(0,1),num_foods)\n  \n  for (t in seq((tmax-1),1,-1)) {\n    \n    for (x in xcrit:xmax) {\n      \n      value_max <- -10\n      \n      # Iterate across decisions\n      for (i in 1:num_decisions) {\n        d_i <- decisions[i,]\n        res_i <- as.numeric(d_i[1])\n        chi <- as.numeric(d_i[2])\n        rho <- as.numeric(d_i[3])\n        \n        xp <- numeric(max_enc+1)\n        tic <- 0\n        for (k in 0:max_enc) {\n          tic <- tic + 1\n          \n          #ENERGETIC DYNAMICS\n          xp[tic] <- x + min((eta[sp,res_i]*g_forage[sp,res_i]*k)/chi, xs) - \n            c_forage[sp,res_i]*chi - rho*c_rep[sp]\n          \n          #Determine Boundary Conditions\n          \n          #Define upper and lower for interpolation\n          \n          \n          #Define k Fitness Value\n          Wxp[k] <- \n          \n        } # end k\n        \n        # Define Cumulative Fitness Value\n        \n      } #end i\n      \n      #Save decision list and fitness values (per x, per t)\n      \n    } #end x\n  } #end t\n} #end sp\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1410368517648.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1864192902",
    "id" : "85B4229E",
    "lastKnownWriteTime" : 1405365403,
    "path" : "~/Dropbox/PostDoc/2014_Foodweb_SDP/Foodweb SDP Program/Foodweb SDP.R",
    "project_path" : "Foodweb SDP.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}