{
    "contents" : "library(RColorBrewer)\nlibrary(Rcpp)\nlibrary(igraph)\nlibrary(beanplot)\ncolors <- brewer.pal(10,\"Spectral\")\n\nnum.res <- 5\nres.bs <- round(rgamma(num.res,shape=5,scale=2),0)\ncons.bs <- max(res.bs + 5)\n\n#Define state matrices for consumer\ntmax <- 10\nstate.matrix <-  matrix(0,cons.bs,tmax)\n\n#Define critical threshold for consumer\nxc <- round((5/8)*cons.bs,0)\nxmax <- cons.bs\n\n#Define terminal fitness function\n#Currently just a increasing function with respect to x... NEED REFINED\nfor (i in xc:cons.bs) {\n    state.matrix[i,tmax] <- i/cons.bs\n}\n\n#Define Spatial landscape & attributes\n#Nunmber of spatial patches\nn <- 25\nlattice.net <- graph.lattice(dimvector=c(sqrt(n),sqrt(n)),directed=FALSE,mutual=TRUE)\nadj.m <- get.adjacency(lattice.net)\nplot(lattice.net,vertex.size=degree(lattice.net),vertex.color=colors[1],edge.color=\"lightblue\",edge.arrow.size=0.6)\n\n#Find the nearest neighbors of each node\nnn <- list()\nfor (j in 1:n) {\n  arow <- adj.m[j,]\n  nn[[j]] <- which(arow==1)\n}\nnum.nn <- unlist(lapply(nn,length))\nnum.nn2 <- num.nn\n\n#How many nearest neighbors does each nearest neighbor have? (minus the node of interest)\nnn2 <- list()\nfor (i in 1:n) {\n  nn2[[i]] <- unlist(lapply(nn[c(nn[[i]])],function(x){length(x)}))\n}\n\n#Variability in the local region\nnn2.sd <- unlist(lapply(nn2,sd))\n\n#Plot Graph where the vertex size is scaled to the 'local landscape variability\"\nplot(lattice.net,vertex.size=(nn2.sd+1)*3,vertex.label=NA,vertex.color=colors[1],edge.color=\"lightblue\",edge.arrow.size=0.6)\n\n\n#Mean encounter rates of prey in region i should be scaled to the number of nearest neighbors to i\n#Dispersion of prey in region i should be scaled to the variability in nearest neighbors to nearest neighbors in i\n#This is essentially the \"Local Heterogeneity\"\nxi <- matrix(0,n,num.res)\nnu <- matrix(0,n,num.res)\nfor (i in 1:n) {\n  for (j in 1:num.res) {\n    xi[i,j] <- (1/res.bs[j])*10*num.nn[i]\n    #nu[i,j] <- (1/res.bs[j])*10*(nn2.sd[i]+2)\n    nu[i,j] <- nn2.sd[i]*2\n  }\n}\n\nmax.enc <- 20\nf.patch <- vector(\"list\",n)\nf.res.patch <- lapply(f.patch,function(x){matrix(0,(max.enc+1),num.res)})\nfor (i in 1:n) {\n  for (j in 1:num.res) {\n    for (k in 1:(max.enc+1)) {\n      f.res.patch[[i]][k,j] <-  dnbinom(k,mu = xi[i,j], size = nu[i,j])\n    }\n    f.res.patch[[i]][,j] <- f.res.patch[[i]][,j] / sum(f.res.patch[[i]][,j])\n  }\n}\n\n#Consumer-resource mortality rates\nRatio.RC <- res.bs/cons.bs\nmp1 <- 0.2\nmort <- 0.5 - 0.5*(1 - 2*mp1)^(Ratio.RC^2)\n\n#Foraging Gains and Costs (allometric and stoichiometric)\nc.forage <- cons.bs^(1/4)\nc.rep <- 0.05*cons.bs\neta <- numeric(num.res)\ng.forage <- numeric(num.res)\nfor (i in 1:num.res) {\n  #Foraging costs/gains conditional on consumer AND resource\n  eta[i] <- 0.1\n  #Gains/costs scale allometrically\n  g.forage[i] <- eta[i]*res.bs[i]\n}\n\n#Build consumer fitness matrix\nW_x <- matrix(0,cons.bs,tmax)\nistar <-  matrix(0,cons.bs,(tmax-1))\n\nnum.dec <- 10\na.beta <- seq(1,5,length.out = num.dec)\nb.beta <- seq(5,1,length.out = num.dec)\nmean.beta <- a.beta/(a.beta + b.beta)\nparam.beta <- cbind(a.beta,b.beta)\n\n#Resource similarity ~ cosine similarity index\nres.sim <- matrix(0,num.res,num.res)\nfor (i in 1:num.res) {\n  for (j in 1:num.res) {\n    resi.att <- c(1,res.bs[i]) #in multidimensional trait space, this would be a vector of attributes\n    resj.att <- c(1,res.bs[j])\n    res.sim[i,j] <- (resi.att %*% resj.att)/ sqrt((resi.att %*% resi.att) * (resj.att %*% resj.att))\n  }\n}\n#stretch between 0 and 1 for each similarity column\nfor (i in 1:num.res) {\n  res.sim.low <- res.sim[,i] - (min(res.sim[,i]))\n  res.sim[,i] <- res.sim.low/max(res.sim.low)\n}\n\n\n#Build decision probabilities\ndec.ls <- list()\nfor (j in 1:num.res) {\n  dec.beta <- matrix(0,num.res,num.dec)\n  for (i in 1:num.dec) {\n    dec.beta[,i] <- dbeta(res.sim[,j],shape1=param.beta[i,1],shape2=param.beta[i,2])\n  }\n  #Normalize to sum to 1\n  dec.beta.n <- apply(dec.beta,2,function(x){x/sum(x)})\n  dec.ls[[j]] <- dec.beta.n\n}\nplot(dec.ls[[1]][,2],type=\"l\",col=colors[1])\nfor (i in 2:10) {lines(dec.ls[[1]][,i],type=\"l\",col=colors[i])}\n#Compute fitness matrices\n#node\n#time\n#current resource\n#energetic state\n\nfor (node in 1:n) {\n  \n  #Loop over time\n  for (t in seq(tmax-1,1,-1)) {\n    \n    #Loop over 'current resource'\n    for (r in 1:num.res) {\n      \n      #Loop over energetic state\n      for (x in seq(xc,xmax,1)) {\n        \n        value_max <- -10\n        \n        \n        #Loop over decisions\n        for (i in 1:num.dec) {\n          \n          xp <- numeric(max.enc+1)\n          \n          \n          \n          \n          \n          \n          \n          \n          \n        }#end decision loop\n        \n        \n        \n      }#end energetic state loop\n      \n      \n      \n    }#end current resource loop\n    \n    \n    \n    \n    \n  }#end time loop\n  \n  \n}#end node loop\n\n\n\n\n\n\n\n\n\n",
    "created" : 1410374792493.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1025721045",
    "id" : "1541A4EC",
    "lastKnownWriteTime" : 1410388598,
    "path" : "~/Dropbox/PostDoc/2014_Foodweb_SDP/Foodweb SDP Program/Consumer_ESL_SDP.R",
    "project_path" : "Consumer_ESL_SDP.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}