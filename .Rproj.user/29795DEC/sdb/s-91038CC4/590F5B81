{
    "contents" : "rm(list=c(ls()))\n\nlibrary(RColorBrewer)\nlibrary(igraph)\nlibrary(intergraph)\nlibrary(Rcpp)\nsourceCpp('src/ESL_meta2.cpp')\n\nt.term <- 1000\nn <- 100\nl <- 200\nX <- matrix(0,n,t.term)\nMeta <- matrix(0,3,t.term)\n#Initiate starting vector\ninitial <- c(n - 2*round(n/3,0),round(n/3,0),round(n/3,0))\nX[,1] <- c(rep(0,initial[1]),rep(1,initial[2]),rep(2,initial[3]))\nMeta[,1] <- initial\n\n#Full Network :: every node is connected to every other node\nadj.m <- matrix(1,n,n); diag(adj.m) <- 0\n\n\n\n\n#Lattice Network\nlattice.net <- graph.lattice(dimvector=c(sqrt(n),sqrt(n)))\nadj.m <- get.adjacency(lattice.net)\nisSymmetric(as.matrix(adj.m))\n\n#Random Network :: nodes are connected randomly\n\n\n\n\n#Exponential Network ::\ndegs <- sample(1:n, n, replace=TRUE, prob=exp(-0.5*(1:n)))\nedgec <- 1\nwhile (edgec != 2*l){\n  degs <- sample(1:n, n, replace=TRUE, prob=(1:n)^-1.8)\n  edgec <- sum(degs)\n}\nif (sum(degs) %% 2 != 0) { degs[1] <- degs[1] + 1 }\nexp.net <- degree.sequence.game(degs, method=\"vl\")\nall(degree(exp.net) == degs)\nadj.m <- get.adjacency(exp.net)\nisSymmetric(adj.m)\n\n#Watts-Strogratz ::\nws.net <- watts.strogatz.game(dim=1,size=n,nei=2,p=0.1)\nadj.m <- get.adjacency(ws.net)\nisSymmetric(adj.m)\n\n#Scale-Free ::\ndegs <- sample(1:n, n, replace=TRUE, prob=(1:n)^-1.8)\nedgec <- 1\nwhile (edgec != 2*l){\n  degs <- sample(1:n, n, replace=TRUE, prob=(1:n)^-1.8)\n  edgec <- sum(degs)\n}\nif (sum(degs) %% 2 != 0) { degs[1] <- degs[1] + 1 }\nsf.net <- degree.sequence.game(degs, method=\"vl\")\nall(degree(sf.net) == degs)\nadj.m <- get.adjacency(sf.net)\nisSymmetric(adj.m)\n\n\n\n\n\n\ncolors <- brewer.pal(3,\"Set1\"); trans <- \"\"\nplot(graph.adjacency(adj.m,mode=\"undirected\"),vertex.size=2,vertex.label=NA,vertex.color=colors[2])\n###########################\n###########################\n###########################\n###########################\n###########################\nsourceCpp('src/ESL_meta.cpp')\n\nt.term <- 5000\nn <- 100\nl <- 200\nX <- matrix(0,n,t.term)\nMeta <- matrix(0,3,t.term)\n#Initiate starting vector\ninitial <- c(n - 2*round(n/3,0),round(n/3,0),round(n/3,0))\nX[,1] <- c(rep(0,initial[1]),rep(1,initial[2]),rep(2,initial[3]))\nMeta[,1] <- initial\n\n#Make list of nearest neighbors for each i\nnn <- list()\nfor (i in 1:n) {\n  arow <- adj.m[i,]\n  nn[[i]] <- which(arow==1)\n}\n\n#Probabilities\nc <- 0.2\nr <- 0.2\nm <- 0.00\nel <- 0.2\nes <- 2*el\n\n#### C++ Version\nnn_cpp = lapply(nn,function(x){x-1})\nESL.out <- ESL_meta(n, t.term, X, Meta, nn_cpp, c, r, m, es, el)\n\ncolors <- brewer.pal(3,\"Set1\"); trans <- \"\"\nplot(ESL.out[[2]][1,]/n,type=\"l\",col=paste(colors[1],trans,sep=\"\"),ylim=c(0,1),xlim=c(0,t.term),lwd=3)\nlines(ESL.out[[2]][2,]/n,col=paste(colors[2],trans,sep=\"\"),lwd=3)\nlines(ESL.out[[2]][3,]/n,col=paste(colors[3],trans,sep=\"\"),lwd=3)\n\n\n# Analysis of C++ simulation\n# Across different types of networks\nsourceCpp('src/ESL_meta2.cpp')\n#Length of simulation\nt.term <- 5000\n#Number of nodes\nn <- 100\n#Number of links\nl <- 200\nrepetitions <- 10\n\nMG <- list()\ngraphs <- list()\n\n#Full Network\nfull.adj.m <- matrix(1,n,n); diag(full.adj.m) <- 0\nfull.net <- graph.adjacency(full.adj.m)\ngraphs[[1]] <- full.net\n\n#Lattice Network\nlattice.net <- graph.lattice(dimvector=c(sqrt(n),sqrt(n)))\n#isSymmetric(as.matrix(adj.m))\ngraphs[[2]] <- lattice.net\n\n#Random Network\nrandom.net <- erdos.renyi.game(n,l,type=\"gnm\",directed=FALSE,loops=FALSE)\nnc <- no.clusters(random.net)\nwhile (nc > 1) {\n  random.net <- erdos.renyi.game(n,l,type=\"gnm\",directed=FALSE,loops=FALSE)\n  nc <- no.clusters(random.net)\n}\ngraphs[[3]] <- random.net\n\n#Scale Free network\n#Scale-Free ::\ndegs <- sample(1:n, n, replace=TRUE, prob=(1:n)^-1.8)\nedgec <- 1\nwhile (edgec != 2*l){\n  degs <- sample(1:n, n, replace=TRUE, prob=(1:n)^-1.8)\n  edgec <- sum(degs)\n}\nif (sum(degs) %% 2 != 0) { degs[1] <- degs[1] + 1 }\nsf.net <- degree.sequence.game(degs, method=\"vl\")\n#all(degree(sf.net) == degs)\n#isSymmetric(adj.m)\ngraphs[[4]] <- sf.net\n\nfor (i in 1:4) {\n  print(paste(\"Graph \",i,\"/4\"),sep=\"\")\n  \n  net <- graphs[[i]]\n  adj.m <- get.adjacency(net)\n  \n  #Make list of nearest neighbors for each node\n  nn <- list()\n  for (j in 1:n) {\n    arow <- adj.m[j,]\n    nn[[j]] <- which(arow==1)\n  }\n  nn_cpp <- lapply(nn,function(x){x-1})\n  \n  #Extinction sequence (prob(ext) for Large patch)\n  ext.seq <- seq(0,0.4,0.02)\n  \n  m.e <- matrix(0,length(ext.seq),repetitions)\n  m.s <- matrix(0,length(ext.seq),repetitions)\n  m.l <- matrix(0,length(ext.seq),repetitions)\n  \n  #Iterate over different values of large-patch extinction probabilities\n  #NOTE :: These iterations are now all done in C++\n  \n  #for (j in 1:length(ext.seq)) {\n  #for (rep in 1:replicates) {\n  \n  #Define intial conditions\n  X <- matrix(0,n,t.term)\n  Meta <- matrix(0,3,t.term)\n  #Initiate starting vector\n  initial <- c(n - 2*round(n/3,0),round(n/3,0),round(n/3,0))\n  X[,1] <- c(rep(0,initial[1]),rep(1,initial[2]),rep(2,initial[3]))\n  Meta[,1] <- initial\n  \n  #Values of constants\n  #Probabilities\n  c <- 0.2\n  r <- 0.2\n  m <- 0.1\n  #el <- ext.seq[j]\n  #es <- 2*el\n  \n  #Perform Simulation\n  ESL.out <- ESL_meta2(n, t.term, repetitions, X, Meta, nn_cpp, c, r, m, ext.seq)\n  \n  #Save summary statistics\n  for (j in 1:length(ext.seq)) {\n    m.e[j,] <- ESL.out[[1]][[j]][1,]/n\n    m.s[j,] <- ESL.out[[1]][[j]][2,]/n\n    m.l[j,] <- ESL.out[[1]][[j]][3,]/n\n  }  \n  \n  #} #end r\n  #} #end j\n  \n  M <- list()\n  \n  M[[1]] <- m.e\n  M[[2]] <- m.s\n  M[[3]] <- m.l\n  \n  MG[[i]] <- M\n  \n}# end i\nimage_filename <- paste(\"/Users/justinyeakel/Dropbox/Postdoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/Results/ESL_m\",m,\".RData\",sep=\"\")\nsave.image(image_filename)\n\nload(\"/Users/justinyeakel/Dropbox/Postdoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/Results/ESL_m0.RData\")\n\npdf_filename <- paste(\"/Users/justinyeakel/Dropbox/Postdoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/Results/ESL_m\",m,\".pdf\",sep=\"\")\n\ncolors <- brewer.pal(3,\"Set1\"); trans <- \"\"\ndev.off()\npdf(file=pdf_filename\n    ,width=6.5,height=14)\nop <- par(mfrow = c(4,1),\n          oma = c(5,4,0,0) + 0.1,\n          mar = c(0,3,1,1) + 0.1,\n          mgp = c(2, 1, 0))\nfor (i in 1:4) {\n  \n  m.e <- MG[[i]][[1]]\n  m.s <- MG[[i]][[2]]\n  m.l <- MG[[i]][[3]]\n  if (i == 4) {\n    plot(ext.seq/c,apply(m.e,1,mean),type=\"l\",col=colors[1],xlim=c(0,2),ylim=c(0,1),xlab=\"e/c\",ylab=\"Proportion\")\n  } else {plot(ext.seq/c,apply(m.e,1,mean),type=\"l\",col=colors[1],xlim=c(0,2),ylim=c(0,1), xaxt='n', ann=FALSE)}\n  polygon(x=c(ext.seq/c,rev(ext.seq/c)),\n          y=c(apply(m.e,1,mean)+apply(m.e,1,sd),rev(apply(m.e,1,mean)-apply(m.e,1,sd))),col=paste(colors[1],\"50\",sep=\"\"),border=NA)\n  lines(ext.seq/c,apply(m.s,1,mean),col=colors[2])\n  polygon(x=c(ext.seq/c,rev(ext.seq/c)),\n          y=c(apply(m.s,1,mean)+apply(m.s,1,sd),rev(apply(m.s,1,mean)-apply(m.s,1,sd))),col=paste(colors[2],\"50\",sep=\"\"),border=NA)\n  lines(ext.seq/c,apply(m.l,1,mean),col=colors[3])\n  polygon(x=c(ext.seq/c,rev(ext.seq/c)),\n          y=c(apply(m.l,1,mean)+apply(m.l,1,sd),rev(apply(m.l,1,mean)-apply(m.l,1,sd))),col=paste(colors[3],\"50\",sep=\"\"),border=NA)\n  lines(ext.seq/c,apply(m.s,1,mean)+apply(m.l,1,mean),col=\"black\",lty=2)\n}\npar(op)\ndev.off()\n\n\n\n#Difference in overall persistence between Lattice and SF networks\nload(\"/Users/justinyeakel/Dropbox/Postdoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/Results/ESL_m0.RData\")\nDiffm0 = apply(MG[[4]][[2]] + MG[[4]][[3]],1,mean) - apply(MG[[3]][[2]] + MG[[3]][[3]],1,mean)\nload(\"/Users/justinyeakel/Dropbox/Postdoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/Results/ESL_m0.1.RData\")\nDiffm1 = apply(MG[[4]][[2]] + MG[[4]][[3]],1,mean) - apply(MG[[3]][[2]] + MG[[3]][[3]],1,mean)\npdf(file=\"/Users/justinyeakel/Dropbox/Postdoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/Results/ESL_Diff.pdf\",width=5.5,height=5.0)\nplot(ext.seq/c,Diffm0,type=\"l\",lwd=2,col=colors[2],xlim=c(0,2),ylim=c(-0.2,0.7),xlab=\"e/c\",ylab=\"Difference in Cum. Proportion (SF-Rand)\")\nlines(ext.seq/c,Diffm1,lwd=2,col=colors[3])\nlines(seq(0,2,0.1),rep(0,21),lty=3)\ndev.off()\n\n\n\n\n#Lattice Network\nn <- 16 #Must be a 'square-rootable number'\n#Probability that a single direction edge exists between 2 vertices\np.single <- 1\n\nlattice.net <- graph.lattice(dimvector=c(sqrt(n),sqrt(n)),directed=TRUE,mutual=TRUE)\nadj.m <- get.adjacency(lattice.net)\nedgel <- get.edgelist(lattice.net)\nedgel.new <- edgel\nskip <- 0\ntic <- 0\ndel.link <- numeric()\nfor (i in 1:length(edgel[,1])) {\n  if ((i %in% skip) == FALSE) {\n    link <- edgel[i,]\n    pos1 <- which(apply(edgel,1,function(x){(x[1]==link[1] && x[2]==link[2])})==TRUE)\n    pos2 <- which(apply(edgel,1,function(x){(x[1]==link[2] && x[2]==link[1])})==TRUE)\n    skip <- c(skip,pos1,pos2)\n    draw.single <- runif(1)\n    if (draw.single < p.single) {\n      tic <- tic + 1\n      del.link[tic] <- sample(c(pos1,pos2),1)\n    }\n  }\n}\nif (length(del.link > 0)) {\n  edgel.new <- edgel.new[-del.link,]\n}\n\n\n#####################################\n#With distributions of Directed Links\n#####################################\nrm(list=c(ls()))\n\n#LOOP over values for p.single\nsourceCpp('src/ESL_meta2.cpp')\n\n\n\n#Length of simulation\nt.term <- 5000\n#Number of nodes\nn <- 100\n#Number of links\nl <- 200\nrepetitions <- 10\np.single.vec <- seq(0,1,0.1)\n\ngraphs <- list()\n\n# #Build initial nets first\n# #Full\n# full.adj.m <- matrix(1,n,n); diag(full.adj.m) <- 0\n# full.net <- graph.adjacency(full.adj.m)\n# graphs[[1]] <- full.net\n\n#Lattice\nlattice.net <- graph.lattice(dimvector=c(sqrt(n),sqrt(n)),directed=TRUE,mutual=TRUE)\ngraphs[[1]] <- lattice.net\n\n#Random net\nrandom.net <- erdos.renyi.game(n,l,type=\"gnm\",directed=FALSE,loops=FALSE)\nnc <- no.clusters(random.net)\nwhile (nc > 1) {\n  random.net <- erdos.renyi.game(n,l,type=\"gnm\",directed=FALSE,loops=FALSE)\n  nc <- no.clusters(random.net)\n}\ngraphs[[2]] <- random.net\n\n#Scale Free\n#Scale-Free ::\ndegs <- sample(1:n, n, replace=TRUE, prob=(1:n)^-1.8)\nedgec <- 1\nwhile (edgec != 2*l){\n  degs <- sample(1:n, n, replace=TRUE, prob=(1:n)^-1.8)\n  edgec <- sum(degs)\n}\nif (sum(degs) %% 2 != 0) { degs[1] <- degs[1] + 1 }\nsf.net <- degree.sequence.game(out.deg=degs, method=\"vl\")\ngraphs[[3]] <- sf.net\n\nMGP <- list()\n\nfor (ps in 1:length(p.single.vec)) {\n  \n  p.single <- p.single.vec[ps]\n  \n  MG <- list()\n  dir.graphs <- list()\n  for (i in 1:3) {\n    \n    print(paste(\"Pr(single link)=\",p.single,\"/1.0 :: \",\"Graph \",i,\"/4\"),sep=\"\")\n    \n    #Select Network\n#     if (i == 1) {\n#       #Full Network :: every node is connected to every other node\n#       #adj.m <- get.adjacency(full.net)\n#       edgel <- get.edgelist(full.net)\n#       edgel.new <- edgel\n#       skip <- 0\n#       tic <- 0\n#       del.link <- numeric()\n#       for (k in 1:length(edgel[,1])) {\n#         if ((k %in% skip) == FALSE) {\n#           link <- edgel[k,]\n#           pos1 <- which(apply(edgel,1,function(x){(x[1]==link[1] && x[2]==link[2])})==TRUE)\n#           pos2 <- which(apply(edgel,1,function(x){(x[1]==link[2] && x[2]==link[1])})==TRUE)\n#           skip <- c(skip,pos1,pos2)\n#           draw.single <- runif(1)\n#           if (draw.single < p.single) {\n#             tic <- tic + 1\n#             del.link[tic] <- sample(c(pos1,pos2),1)\n#           }\n#         }\n#       }\n#       if (length(del.link > 0)) {\n#         edgel.new <- edgel.new[-del.link,]\n#       }\n#       full.net.dir <- graph.edgelist(edgel.new)\n#       adj.m <- get.adjacency(full.net.dir)\n#       #graphs[[i]] <- full.net.dir\n#     }\n    if (i == 1) {\n      edgel <- get.edgelist(lattice.net)\n      edgel.new <- edgel\n      skip <- 0\n      tic <- 0\n      del.link <- numeric()\n      for (k in 1:length(edgel[,1])) {\n        if ((k %in% skip) == FALSE) {\n          link <- edgel[k,]\n          pos1 <- which(apply(edgel,1,function(x){(x[1]==link[1] && x[2]==link[2])})==TRUE)\n          pos2 <- which(apply(edgel,1,function(x){(x[1]==link[2] && x[2]==link[1])})==TRUE)\n          skip <- c(skip,pos1,pos2)\n          draw.single <- runif(1)\n          if (draw.single < p.single) {\n            tic <- tic + 1\n            del.link[tic] <- sample(c(pos1,pos2),1)\n          }\n        }\n      }\n      if (length(del.link > 0)) {\n        edgel.new <- edgel.new[-del.link,]\n      }\n      lattice.net.dir <- graph.edgelist(edgel.new)\n      adj.m <- get.adjacency(lattice.net.dir)\n      #isSymmetric(as.matrix(adj.m))\n      dir.graphs[[i]] <- lattice.net.dir\n    }\n    if (i == 2) {\n      edgelist_in <- get.edgelist(random.net)\n      edgelist_out <- matrix(0,length(edgelist_in[,1]),2)\n      edgelist_out[,1] <- edgelist_in[,2]; edgelist_out[,2] <- edgelist_in[,1]\n      edgelist_dir <- rbind(edgelist_in,edgelist_out)\n      random.net.dir <- graph.edgelist(edgelist_dir,directed=TRUE) #FULLY BIDIRECTIONAL GRAPH\n      edgel <- get.edgelist(random.net.dir)\n      edgel.new <- edgel\n      skip <- 0\n      tic <- 0\n      del.link <- numeric()\n      for (k in 1:length(edgel[,1])) {\n        if ((k %in% skip) == FALSE) {\n          link <- edgel[k,]\n          pos1 <- which(apply(edgel,1,function(x){(x[1]==link[1] && x[2]==link[2])})==TRUE)\n          pos2 <- which(apply(edgel,1,function(x){(x[1]==link[2] && x[2]==link[1])})==TRUE)\n          skip <- c(skip,pos1,pos2)\n          draw.single <- runif(1)\n          if (draw.single < p.single) {\n            tic <- tic + 1\n            del.link[tic] <- sample(c(pos1,pos2),1)\n          }\n        }\n      }\n      if (length(del.link > 0)) {\n        edgel.new <- edgel.new[-del.link,]\n      }\n      random.net.dir <- graph.edgelist(edgel.new)\n      adj.m <- get.adjacency(random.net.dir)\n      #isSymmetric(as.matrix(adj.m))\n      dir.graphs[[i]] <- random.net.dir\n    }\n    if (i == 3) {\n      edgelist_in <- get.edgelist(sf.net)\n      edgelist_out <- matrix(0,length(edgelist_in[,1]),2)\n      edgelist_out[,1] <- edgelist_in[,2]; edgelist_out[,2] <- edgelist_in[,1]\n      edgelist_dir <- rbind(edgelist_in,edgelist_out)\n      sf.net.dir <- graph.edgelist(edgelist_dir,directed=TRUE) #FULLY BIDIRECTIONAL GRAPH\n      #all(degree(sf.net) == degs)\n      #adj.m <- get.adjacency(sf.net)\n      #isSymmetric(adj.m)\n      edgel <- get.edgelist(sf.net.dir)\n      edgel.new <- edgel\n      skip <- 0\n      tic <- 0\n      del.link <- numeric()\n      for (k in 1:length(edgel[,1])) {\n        if ((k %in% skip) == FALSE) {\n          link <- edgel[k,]\n          pos1 <- which(apply(edgel,1,function(x){(x[1]==link[1] && x[2]==link[2])})==TRUE)\n          pos2 <- which(apply(edgel,1,function(x){(x[1]==link[2] && x[2]==link[1])})==TRUE)\n          skip <- c(skip,pos1,pos2)\n          draw.single <- runif(1)\n          if (draw.single < p.single) {\n            tic <- tic + 1\n            del.link[tic] <- sample(c(pos1,pos2),1)\n          }\n        }\n      }\n      if (length(del.link > 0)) {\n        edgel.new <- edgel.new[-del.link,]\n      }\n      sf.net.dir <- graph.edgelist(edgel.new)\n      adj.m <- get.adjacency(sf.net.dir)\n      dir.graphs[[i]] <- sf.net.dir\n    }\n    \n    #Make list of nearest neighbors for each node\n    nn <- list()\n    for (j in 1:n) {\n      arow <- adj.m[j,]\n      nn[[j]] <- which(arow==1)\n    }\n    nn_cpp <- lapply(nn,function(x){x-1})\n    \n    #Extinction sequence (prob(ext) for Large patch)\n    ext.seq <- seq(0,0.4,0.02) #Change to seq(0,0.4,0.02) for future runs... or seq(0,0.4,0.01) for the final product\n    \n    m.e <- matrix(0,length(ext.seq),repetitions)\n    m.s <- matrix(0,length(ext.seq),repetitions)\n    m.l <- matrix(0,length(ext.seq),repetitions)\n    \n    #Iterate over different values of large-patch extinction probabilities\n    #NOTE :: These iterations are now all done in C++\n    \n    #for (j in 1:length(ext.seq)) {\n    #for (rep in 1:replicates) {\n    \n    #Define intial conditions\n    X <- matrix(0,n,t.term)\n    Meta <- matrix(0,3,t.term)\n    #Initiate starting vector\n    initial <- c(n - 2*round(n/3,0),round(n/3,0),round(n/3,0))\n    X[,1] <- c(rep(0,initial[1]),rep(1,initial[2]),rep(2,initial[3]))\n    Meta[,1] <- initial\n    \n    #Values of constants\n    #Probabilities\n    c <- 0.2\n    r <- 0.2\n    m <- 0.0\n    #el <- ext.seq[j]\n    #es <- 2*el\n    \n    #Perform Simulation\n    ESL.out <- ESL_meta2(n, t.term, repetitions, X, Meta, nn_cpp, c, r, m, ext.seq)\n    \n    #Save summary statistics\n    for (j in 1:length(ext.seq)) {\n      m.e[j,] <- ESL.out[[1]][[j]][1,]/n\n      m.s[j,] <- ESL.out[[1]][[j]][2,]/n\n      m.l[j,] <- ESL.out[[1]][[j]][3,]/n\n    }  \n    \n    #} #end r\n    #} #end j\n    \n    M <- list()\n    \n    M[[1]] <- m.e\n    M[[2]] <- m.s\n    M[[3]] <- m.l\n    \n    MG[[i]] <- M\n    \n  }# end i\n  \n  \n  MGP[[ps]] <- MG\n  \n  \n}# end ps\n\nimage_filename <- paste(\"/Users/justinyeakel/Dropbox/Postdoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/Results/ESLdir_m\",m,\".RData\",sep=\"\")\nsave.image(image_filename)\n\nload(\"/Users/justinyeakel/Dropbox/Postdoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/Results/ESLdir_m0.RData\")\n\n#Exporing Results for 3D plots in Mathematica\nname_var <- c(\"E\",\"S\",\"L\")\nname_net <- c(\"Full\",\"Lattice\",\"SF\")\nfor (i in 1:3) { #nets\n  for (j in 1:3) { #ESL\n    #Assemble table\n    tab <- matrix(0,length(ext.seq)*length(p.single.vec),3)\n    tic <- 0\n    for (k in 1:length(p.single.vec)) {\n      temp_tab <- apply(MGP[[k]][[i]][[j]],1,mean)\n      tab[seq(length(temp_tab)*tic+1,length(temp_tab)*(tic+1),1),3] <- temp_tab\n      tab[seq(length(temp_tab)*tic+1,length(temp_tab)*(tic+1),1),2] <- p.single.vec[k]\n      tic <- tic + 1\n    }\n    tab[,1] <- rep(ext.seq/c,length(p.single.vec))\n    filename <- paste(\"/Users/justinyeakel/Dropbox/Postdoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/Results/dir_text/dir_m\",m,\"_\",name_net[i],\"_\",name_var[j],\".csv\",sep=\"\")\n    write.table(tab,file=filename,col.names=FALSE,row.names=FALSE,sep=\",\")\n  }\n}\n\n# Contour plot of the effect of directedness on persistence\npdf_filename <- paste(\"/Users/justinyeakel/Dropbox/Postdoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/Results/ESLdir_m\",m,\".pdf\",sep=\"\")\ndev.off()\npdf(file=pdf_filename,width=3.5,height=6)\nop <- par(mfrow = c(3,1),\n          oma = c(5,4,0,0) + 0.1,\n          mar = c(0,3,1,1) + 0.1,\n          mgp = c(2, 1, 0))\ncolors <- brewer.pal(11,\"Spectral\")\nfor (i in 1:3) { # Loop over different networks\n  for (ps in 1:length(p.single.vec)) {\n    tot.pers <- apply(MGP[[ps]][[i]][[2]] + MGP[[ps]][[i]][[3]],1,mean)\n    if (ps == 1) {\n      if (i == 3) {\n        plot(ext.seq/c,tot.pers,type=\"l\",lwd = 2,col=colors[ps],xlim=c(0,2),ylim=c(0,1))\n      } else {plot(ext.seq/c,tot.pers,type=\"l\",lwd = 2,col=colors[ps],xlim=c(0,2),ylim=c(0,1), xaxt='n', ann=FALSE)}\n    } else {\n      lines(ext.seq/c,tot.pers,type=\"l\",lwd=2,col=colors[ps])\n    }\n  }\n}\npar(op)\ndev.off()\n\n\n#Plotting the Graphs\ncolors <- brewer.pal(3,\"Set1\")\nop <- par(mfrow = c(2,3),\n          oma = c(5,4,0,0) + 0.1,\n          mar = c(0,3,1,1) + 0.1,\n          mgp = c(2, 1, 0))\nplot(graphs[[1]],vertex.size=degree(graphs[[1]]),vertex.label=NA,vertex.color=colors[1],edge.color=\"lightblue\",edge.arrow.size=0.6)\nplot(graphs[[2]],vertex.size=degree(graphs[[2]])+2,vertex.label=NA,vertex.color=colors[2],edge.color=\"lightblue\",edge.width=2,edge.arrow.size=0.6)\nplot(graphs[[3]],vertex.size=degree(graphs[[3]])+2,vertex.label=NA,vertex.color=colors[3],edge.color=\"lightblue\",edge.width=2,edge.arrow.size=0.6)\nplot(dir.graphs[[1]],vertex.size=degree(graphs[[1]]),vertex.label=NA,vertex.color=colors[1],edge.color=\"lightblue\",edge.arrow.size=0.6)\nplot(dir.graphs[[2]],vertex.size=degree(graphs[[2]])+2,vertex.label=NA,vertex.color=colors[2],edge.color=\"lightblue\",edge.width=2,edge.arrow.size=0.6)\nplot(dir.graphs[[3]],vertex.size=degree(graphs[[3]])+2,vertex.label=NA,vertex.color=colors[3],edge.color=\"lightblue\",edge.width=2,edge.arrow.size=0.6)\npar(op)\n\nload(\"/Users/justinyeakel/Dropbox/Postdoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/Results/ESLdir_m0.1.RData\")\npdf_filename <- paste(\"/Users/justinyeakel/Dropbox/Postdoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/Results/ESLdir_m\",m,\".pdf\",sep=\"\")\n\n\n\n\n\n\n############################################################################################\n#Determine the DIFFERENCE between p.single=1 and p.single=0 across ranges of e/c and rescue\n############################################################################################\n\n\n\n\n#Build nondirected (p=0) and directed graphs (p=1) to start\n#Length of simulation\nt.term <- 5000\n#Number of nodes\nn <- 100\n#Number of links\nl <- 200\nrepetitions <- 10\np.single <- 1\n\ngraphs <- list()\ndir.graphs <- list()\n\n# #Build initial nets first\n# #Full\n# full.adj.m <- matrix(1,n,n); diag(full.adj.m) <- 0\n# full.net <- graph.adjacency(full.adj.m)\n# graphs[[1]] <- full.net\n\n#Lattice\nlattice.net <- graph.lattice(dimvector=c(sqrt(n),sqrt(n)),directed=TRUE,mutual=TRUE)\ngraphs[[1]] <- lattice.net\nedgel <- get.edgelist(lattice.net)\nedgel.new <- edgel\nskip <- 0\ntic <- 0\ndel.link <- numeric()\nfor (k in 1:length(edgel[,1])) {\n  if ((k %in% skip) == FALSE) {\n    link <- edgel[k,]\n    pos1 <- which(apply(edgel,1,function(x){(x[1]==link[1] && x[2]==link[2])})==TRUE)\n    pos2 <- which(apply(edgel,1,function(x){(x[1]==link[2] && x[2]==link[1])})==TRUE)\n    skip <- c(skip,pos1,pos2)\n    draw.single <- runif(1)\n    if (draw.single < p.single) {\n      tic <- tic + 1\n      del.link[tic] <- sample(c(pos1,pos2),1)\n    }\n  }\n}\nif (length(del.link > 0)) {\n  edgel.new <- edgel.new[-del.link,]\n}\nlattice.net.dir <- graph.edgelist(edgel.new)\nadj.m <- get.adjacency(lattice.net.dir)\n#isSymmetric(as.matrix(adj.m))\ndir.graphs[[1]] <- lattice.net.dir\n\n#Random net\nrandom.net <- erdos.renyi.game(n,l,type=\"gnm\",directed=FALSE,loops=FALSE)\nnc <- no.clusters(random.net)\nwhile (nc > 1) {\n  random.net <- erdos.renyi.game(n,l,type=\"gnm\",directed=FALSE,loops=FALSE)\n  nc <- no.clusters(random.net)\n}\ngraphs[[2]] <- random.net\nedgelist_in <- get.edgelist(random.net)\nedgelist_out <- matrix(0,length(edgelist_in[,1]),2)\nedgelist_out[,1] <- edgelist_in[,2]; edgelist_out[,2] <- edgelist_in[,1]\nedgelist_dir <- rbind(edgelist_in,edgelist_out)\nrandom.net.dir <- graph.edgelist(edgelist_dir,directed=TRUE) #FULLY BIDIRECTIONAL GRAPH\nedgel <- get.edgelist(random.net.dir)\nedgel.new <- edgel\nskip <- 0\ntic <- 0\ndel.link <- numeric()\nfor (k in 1:length(edgel[,1])) {\n  if ((k %in% skip) == FALSE) {\n    link <- edgel[k,]\n    pos1 <- which(apply(edgel,1,function(x){(x[1]==link[1] && x[2]==link[2])})==TRUE)\n    pos2 <- which(apply(edgel,1,function(x){(x[1]==link[2] && x[2]==link[1])})==TRUE)\n    skip <- c(skip,pos1,pos2)\n    draw.single <- runif(1)\n    if (draw.single < p.single) {\n      tic <- tic + 1\n      del.link[tic] <- sample(c(pos1,pos2),1)\n    }\n  }\n}\nif (length(del.link > 0)) {\n  edgel.new <- edgel.new[-del.link,]\n}\nrandom.net.dir <- graph.edgelist(edgel.new)\nadj.m <- get.adjacency(random.net.dir)\n#isSymmetric(as.matrix(adj.m))\ndir.graphs[[2]] <- random.net.dir\n\n#Scale Free\n#Scale-Free ::\ndegs <- sample(1:n, n, replace=TRUE, prob=(1:n)^-1.8)\nedgec <- 1\nwhile (edgec != 2*l){\n  degs <- sample(1:n, n, replace=TRUE, prob=(1:n)^-1.8)\n  edgec <- sum(degs)\n}\nif (sum(degs) %% 2 != 0) { degs[1] <- degs[1] + 1 }\nsf.net <- degree.sequence.game(out.deg=degs, method=\"vl\")\ngraphs[[3]] <- sf.net\nedgelist_in <- get.edgelist(sf.net)\nedgelist_out <- matrix(0,length(edgelist_in[,1]),2)\nedgelist_out[,1] <- edgelist_in[,2]; edgelist_out[,2] <- edgelist_in[,1]\nedgelist_dir <- rbind(edgelist_in,edgelist_out)\nsf.net.dir <- graph.edgelist(edgelist_dir,directed=TRUE) #FULLY BIDIRECTIONAL GRAPH\n#all(degree(sf.net) == degs)\n#adj.m <- get.adjacency(sf.net)\n#isSymmetric(adj.m)\nedgel <- get.edgelist(sf.net.dir)\nedgel.new <- edgel\nskip <- 0\ntic <- 0\ndel.link <- numeric()\nfor (k in 1:length(edgel[,1])) {\n  if ((k %in% skip) == FALSE) {\n    link <- edgel[k,]\n    pos1 <- which(apply(edgel,1,function(x){(x[1]==link[1] && x[2]==link[2])})==TRUE)\n    pos2 <- which(apply(edgel,1,function(x){(x[1]==link[2] && x[2]==link[1])})==TRUE)\n    skip <- c(skip,pos1,pos2)\n    draw.single <- runif(1)\n    if (draw.single < p.single) {\n      tic <- tic + 1\n      del.link[tic] <- sample(c(pos1,pos2),1)\n    }\n  }\n}\nif (length(del.link > 0)) {\n  edgel.new <- edgel.new[-del.link,]\n}\nsf.net.dir <- graph.edgelist(edgel.new)\nadj.m <- get.adjacency(sf.net.dir)\ndir.graphs[[3]] <- sf.net.dir\n\nMRG <- list()\nMRG.dir <- list()\n\n#Loop through Graphs\nfor (i in 1:3) {\n  \n  MR <- list()\n  MR.dir <- list()\n  \n  #Loop through Rescue Effects\n  m.seq <- seq(0,1,0.1)\n  for (resc in 1:length(m.seq)) {\n    \n    m <- m.seq[resc]\n    \n    print(paste(\"Graphs = \",i,\"/3 :: Rescue Effect = \",m,sep=\"\"))\n    \n    #Establish adjacency matrix\n    if (i==1) {\n      adj.m <- get.adjacency(lattice.net)\n      adj.m.dir <- get.adjacency(lattice.net.dir)\n    }\n    if (i==2) {\n      adj.m <- get.adjacency(random.net)\n      adj.m.dir <- get.adjacency(random.net.dir)\n    }\n    if (i==3) {\n      adj.m <- get.adjacency(sf.net)\n      adj.m.dir <- get.adjacency(sf.net.dir)\n    }\n    \n    #Make list of nearest neighbors for each node\n    nn <- list()\n    for (j in 1:n) {\n      arow <- adj.m[j,]\n      nn[[j]] <- which(arow==1)\n    }\n    nn_cpp <- lapply(nn,function(x){x-1})\n    \n    nn.dir <- list()\n    for (j in 1:n) {\n      arow <- adj.m.dir[j,]\n      nn.dir[[j]] <- which(arow==1)\n    }\n    nn_cpp_dir <- lapply(nn.dir,function(x){x-1})\n    \n    #Extinction sequence (prob(ext) for Large patch)\n    ext.seq <- seq(0,0.4,0.02) #Change to seq(0,0.4,0.02) for future runs... or seq(0,0.4,0.01) for the final product\n    \n    m.e <- matrix(0,length(ext.seq),repetitions)\n    m.s <- matrix(0,length(ext.seq),repetitions)\n    m.l <- matrix(0,length(ext.seq),repetitions)\n    \n    m.e.dir <- matrix(0,length(ext.seq),repetitions)\n    m.s.dir <- matrix(0,length(ext.seq),repetitions)\n    m.l.dir <- matrix(0,length(ext.seq),repetitions)\n    \n    #Iterate over different values of large-patch extinction probabilities\n    #NOTE :: These iterations are now all done in C++\n    \n    #for (j in 1:length(ext.seq)) {\n    #for (rep in 1:replicates) {\n    \n    #Define intial conditions\n    X <- matrix(0,n,t.term)\n    Meta <- matrix(0,3,t.term)\n    #Initiate starting vector\n    initial <- c(n - 2*round(n/3,0),round(n/3,0),round(n/3,0))\n    X[,1] <- c(rep(0,initial[1]),rep(1,initial[2]),rep(2,initial[3]))\n    Meta[,1] <- initial\n    \n    #Values of constants\n    #Probabilities\n    c <- 0.2\n    r <- 0.2\n    #el <- ext.seq[j]\n    #es <- 2*el\n    \n    #Perform Simulation\n    ESL.out <- ESL_meta2(n, t.term, repetitions, X, Meta, nn_cpp, c, r, m, ext.seq)\n    ESL.out.dir <- ESL_meta2(n, t.term, repetitions, X, Meta, nn_cpp_dir, c, r, m, ext.seq)\n    \n    #Save summary statistics\n    #These are matrices of mean proportions with ext.seq=rows and repetitions=columns...\n    for (j in 1:length(ext.seq)) {\n      m.e[j,] <- ESL.out[[1]][[j]][1,]/n\n      m.s[j,] <- ESL.out[[1]][[j]][2,]/n\n      m.l[j,] <- ESL.out[[1]][[j]][3,]/n\n    } \n    for (j in 1:length(ext.seq)) {\n      m.e.dir[j,] <- ESL.out.dir[[1]][[j]][1,]/n\n      m.s.dir[j,] <- ESL.out.dir[[1]][[j]][2,]/n\n      m.l.dir[j,] <- ESL.out.dir[[1]][[j]][3,]/n\n    } \n    \n    #} #end r\n    #} #end j\n    \n    M <- list()\n    M.dir <- list()\n    \n    M[[1]] <- m.e\n    M[[2]] <- m.s\n    M[[3]] <- m.l\n    \n    M.dir[[1]] <- m.e.dir\n    M.dir[[2]] <- m.s.dir\n    M.dir[[3]] <- m.l.dir\n    \n    MR[[resc]] <- M\n    \n    MR.dir[[resc]] <- M.dir\n    \n  } # end resc\n  \n  MRG[[i]] <- MR\n  MRG.dir[[i]] <- MR.dir\n  \n} # end i\nimage_filename <- paste(\"/Users/justinyeakel/Dropbox/Postdoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/Results/ESL_DirectedDifference.RData\",sep=\"\")\nsave.image(image_filename)\n\ncolors <- brewer.pal(11,\"Spectral\")\n\n\nfor (i in 1:3) {\n  pdf_filename <- paste(\"/Users/justinyeakel/Dropbox/Postdoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/Results/ESL_DirectedDifference_Graph\",i,\".pdf\",sep=\"\")\n  pdf(file=pdf_filename,width=12,height=8)\n  op <- par(mfrow = c(3,4),\n            oma = c(5,4,0,0) + 0.1,\n            mar = c(0,3,3,1) + 0.1,\n            mgp = c(2, 1, 0))\n  cum.diff.matrix <- matrix(0,length(ext.seq),length(m.seq))\n  for (resc in 1:length(m.seq)) {\n    cum.prop.undir <- apply(MRG[[i]][[resc]][[2]],1,mean) + apply(MRG[[i]][[resc]][[3]],1,mean)\n    cum.prop.dir <- apply(MRG.dir[[i]][[resc]][[2]],1,mean) + apply(MRG.dir[[i]][[resc]][[3]],1,mean)\n    cum.diff <- cum.prop.undir - cum.prop.dir\n    #cum.diff.nonzero <- cum.diff[which(cum.diff != 0)]\n    cum.diff.matrix[,resc] <- cum.diff\n    plot(ext.seq/c,cum.prop.undir,type=\"l\",ylim=c(0,1),col=colors[resc],lwd=2)\n    lines(ext.seq/c,cum.prop.dir,lty=2,col=colors[resc],lwd=2)\n  }\n  par(op)\n  dev.off()\n}\n\n#BoxPlot\npdf_filename <- paste(\"/Users/justinyeakel/Dropbox/Postdoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/Results/ESL_DirectedDifference_Boxplots.pdf\",sep=\"\")\npdf(file=pdf_filename,width=8,height=12)\nop <- par(mfrow = c(3,1),\n          oma = c(5,4,0,0) + 0.1,\n          mar = c(0,3,1,1) + 0.1,\n          mgp = c(2, 1, 0))\nfor (i in 1:3) {\n  cum.diff.matrix <- matrix(0,length(ext.seq),length(m.seq))\n  for (resc in 1:length(m.seq)) {\n    cum.prop.undir <- apply(MRG[[i]][[resc]][[2]],1,mean) + apply(MRG[[i]][[resc]][[3]],1,mean)\n    cum.prop.dir <- apply(MRG.dir[[i]][[resc]][[2]],1,mean) + apply(MRG.dir[[i]][[resc]][[3]],1,mean)\n    cum.diff <- cum.prop.undir - cum.prop.dir\n    #cum.diff.nonzero <- cum.diff[which(cum.diff != 0)]\n    cum.diff.matrix[,resc] <- cum.diff\n  }\n  boxplot(cum.diff.matrix,boxwex=0.5,col=colors,names=m.seq,ylim=c(0,1),ylab=c(\"Cum. proportion differences (undirected-directed)\"))\n}\npar(op)\ndev.off()\n\n\n\n\n\n\n\n\n\n\n\n\n#### R Version\n\n\n\npr.Grow <- matrix(0,n,t.term)\npr.NoGrowRescue <- matrix(0,n,t.term)\npr.NoGrowNoRescueStay <- matrix(0,n,t.term)\npr.NoGrowNoRescueExtinct <- matrix(0,n,t.term)\npr.Colonize <- matrix(0,n,t.term)\n\nnn.state <- list()\n\nfor (t in 1:(t.term-1)) {\n  \n  XE <- which(X[,t]==0)\n  num.E <- length(XE)\n  \n  XS <- which(X[,t]==1)\n  num.S <- length(XS)\n  \n  XL <- which(X[,t]==2)\n  num.L <- length(XL)\n  \n  #Determine state for each nearest neighbor of i\n  for (i in 1:n) {\n    nn.state[[i]] <- X[nn[[i]],t]\n  }\n  \n  #Empty Dynamics\n  for (i in XE) {\n    #How many Large nodes are nearest neighbors to node i?\n    num.L <- length(which(nn.state[[i]] == 2))\n    \n    pr.ES <- 1-(1-c)^num.L\n    \n    draw.ES <- runif(1)\n    \n    if (draw.ES < pr.ES) {\n      X[i,t+1] <- 1\n    } else {X[i,t+1] <- 0}\n    \n    pr.Colonize[i,t] <- pr.ES\n  }\n  \n  #Small Dynamics\n  for (i in XS) {\n    #How many Large nodes are nearest neighbors to node i?\n    num.L <- length(which(nn.state[[i]] == 2))\n    \n    pr.SL.grow <- r\n    draw.SL.grow <- runif(1)\n    if (draw.SL.grow < pr.SL.grow) {\n      X[i,t+1] <- 2\n    } else {\n      pr.SL.rescue <- (1-(1-m)^num.L)\n      draw.SL.rescue <- runif(1)\n      if (draw.SL.rescue < pr.SL.rescue) {\n        X[i,t+1] <- 2\n      } else {\n        pr.S.stay <- (1 - es)\n        draw.S.stay <- runif(1)\n        if (draw.S.stay < pr.S.stay) {\n          X[i,t+1] <- 1\n        } else {X[i,t+1] <- 0}\n      }\n    }\n    #What can happen to you as an S?\n    #The sum better Sam-Hell equal 1!\n    pr.Grow[i,t] <- pr.SL.grow\n    pr.NoGrowRescue[i,t] <- (1-pr.SL.grow)*pr.SL.rescue\n    pr.NoGrowNoRescueStay[i,t] <- (1-pr.SL.grow)*(1-pr.SL.rescue)*(1-es)\n    pr.NoGrowNoRescueExtinct[i,t] <- (1-pr.SL.grow)*(1-pr.SL.rescue)*es\n  }\n \n  \n  \n  \n  #Large Dynamics\n  for (i in XL) {\n    pr.LS.shrink <- el\n    draw.LS.shrink <- runif(1)\n    if (draw.LS.shrink < pr.LS.shrink) {\n      X[i,t+1] <- 1\n    } else {\n      X[i,t+1] <- 2\n    }\n  }\n\n  XE.next <- which(X[,t+1]==0)\n  num.E.next <- length(XE.next)\n  \n  XS.next <- which(X[,t+1]==1)\n  num.S.next <- length(XS.next)\n  \n  XL.next <- which(X[,t+1]==2)\n  num.L.next <- length(XL.next)\n  \n  Meta[,t+1] <- c(num.E.next,num.S.next,num.L.next)\n\n}\n\n#par(mfrow=c(2,1))\n#E = Red\n#S = Blue\n#L = Green\ncolors <- brewer.pal(3,\"Set1\"); trans <- \"\"\nplot(Meta[1,]/n,type=\"l\",col=paste(colors[1],trans,sep=\"\"),ylim=c(0,1),xlim=c(0,t.term),lwd=3)\nlines(Meta[2,]/n,col=paste(colors[2],trans,sep=\"\"),lwd=3)\nlines(Meta[3,]/n,col=paste(colors[3],trans,sep=\"\"),lwd=3)\n#Rescue = green\n#Stay = orange\n#Extinct = blue\n#Colonize = pink\ncolors <- brewer.pal(4,\"Set2\"); trans <- \"\"\nplot(apply(pr.NoGrowRescue,2,mean),type=2,col=paste(colors[1],trans,sep=\"\"),ylim=c(0,0.2),xlim=c(0,t.term),lwd=3)\nlines(apply(pr.NoGrowNoRescueStay,2,mean),col=paste(colors[2],trans,sep=\"\"),lwd=3)\nlines(apply(pr.NoGrowNoRescueExtinct,2,mean),col=paste(colors[3],trans,sep=\"\"),lwd=3)\nlines(apply(pr.Colonize,2,mean),col=paste(colors[4],trans,sep=\"\"),lwd=3)\n\ncolors <- brewer.pal(4,\"Set2\"); trans <- \"\"\nplot(apply(pr.NoGrowRescue,2,sd),type=2,col=paste(colors[1],trans,sep=\"\"),ylim=c(0,0.5),xlim=c(0,t.term),lwd=3)\nlines(apply(pr.NoGrowNoRescueStay,2,sd),col=paste(colors[2],trans,sep=\"\"),lwd=3)\nlines(apply(pr.NoGrowNoRescueExtinct,2,sd),col=paste(colors[3],trans,sep=\"\"),lwd=3)\nlines(apply(pr.Colonize,2,sd),col=paste(colors[4],trans,sep=\"\"),lwd=3)\n\n\n\npar(mfrow=c(1,1))\ncolors <- brewer.pal(3,\"Set1\"); trans <- \"\"\nplot((Meta[2,]+Meta[3,])/n,type=2,col=paste(colors[2],trans,sep=\"\"),ylim=c(0,1),xlim=c(0,t.term),lwd=3)\n\n\n\n",
    "created" : 1410375917800.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3598170173",
    "id" : "590F5B81",
    "lastKnownWriteTime" : 1409862397,
    "path" : "~/Dropbox/PostDoc/2014_Empirical_Watersheds/Optimal_Channel_Nets/ESL_MarkovDynamics2.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}